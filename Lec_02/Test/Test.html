<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест: Микросървиси и Контейнери</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .answer-btn {
            transition: background-color 0.3s, transform 0.2s;
        }
        .answer-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .correct {
            background-color: #22c55e !important; /* green-500 */
            color: white;
            border-color: #16a34a; /* green-600 */
        }
        .incorrect {
            background-color: #ef4444 !important; /* red-500 */
            color: white;
            border-color: #dc2626; /* red-600 */
        }
        .rationale {
            font-size: 0.875rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="w-full max-w-3xl mx-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8">
        <div id="question-header" class="mb-6">
            <h1 class="text-3xl font-bold text-center mb-2 text-cyan-400">Тест: Микросървиси и Контейнери</h1>
            <p id="progress-text" class="text-center text-gray-400">Въпрос 1 от 50</p>
        </div>

        <div id="question-area">
            <h2 id="question-text" class="text-xl md:text-2xl font-semibold mb-6 min-h-[6rem]">Зареждане на въпрос...</h2>
            <div id="answer-buttons" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Answer buttons will be generated here -->
            </div>
             <div id="hint-container" class="mt-4 text-center">
                <button id="hint-btn" class="text-sm text-cyan-400 hover:text-cyan-300">Покажи подсказка</button>
                <p id="hint-text" class="hidden mt-2 text-gray-400 bg-gray-700 p-2 rounded-lg"></p>
            </div>
        </div>
        
        <div id="results-area" class="hidden text-center">
            <h2 class="text-3xl font-bold mb-4">Тестът приключи!</h2>
            <p class="text-xl mb-6">Вашият резултат: <span id="score-text" class="font-bold text-cyan-400">0 / 50</span></p>
            <button id="restart-btn" class="w-full md:w-auto bg-cyan-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-cyan-600 transition-colors">Започни отначало</button>
        </div>

        <div class="mt-8 flex justify-end">
            <button id="next-btn" class="hidden w-full md:w-auto bg-gray-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-700 transition-colors">Следващ</button>
        </div>
    </div>

    <script>
        const quizData = [
    {
        "questionNumber": 1,
        "question": "Коя от следните характеристики НЕ е типична за монолитната архитектура?",
        "hint": "Помислете как се отразяват промените в кода върху процеса на внедряване при различните архитектури.",
        "answerOptions": [
            {
                "text": "Силна свързаност между модулите",
                "isCorrect": false,
                "rationale": "Това е ключова характеристика на монолитите, където компонентите са тясно интегрирани."
            },
            {
                "text": "Централизирана база данни",
                "isCorrect": false,
                "rationale": "Монолитните приложения обикновено използват една-единствена база данни за всички свои функционалности."
            },
            {
                "text": "Независимо внедряване на компоненти",
                "isCorrect": true,
                "rationale": "В монолитната архитектура всяка промяна изисква повторно внедряване на цялото приложение, а не на отделни компоненти."
            },
            {
                "text": "Използване на единна технология за цялото приложение",
                "isCorrect": false,
                "rationale": "Обикновекновено монолитните приложения се разработват с един основен технологичен стак."
            }
        ]
    },
    {
        "questionNumber": 2,
        "question": "Какъв основен принцип нарушава директният достъп до базата данни на една микроуслуга от друга?",
        "hint": "Кой принцип гласи, че услугите трябва да комуникират само през публично дефинирани интерфейси?",
        "answerOptions": [
            {
                "text": "Принципът за единствената отговорност (Single Responsibility Principle)",
                "isCorrect": false,
                "rationale": "Въпреки че всяка услуга трябва да има една отговорност, този принцип не се отнася пряко за комуникацията между тях."
            },
            {
                "text": "Принципът за енкапсулация и слаба свързаност",
                "isCorrect": true,
                "rationale": "Директният достъп до данните нарушава скриването на вътрешната имплементация и създава силна зависимост."
            },
            {
                "text": "Принципът за автоматизация (Automate everything)",
                "isCorrect": false,
                "rationale": "Този принцип се отнася до процесите на CI/CD и управление на инфраструктурата, а не до комуникацията между услугите."
            },
            {
                "text": "Принципът за полиглотна персистенция",
                "isCorrect": false,
                "rationale": "Този принцип позволява използването на различни бази данни, но не определя как услугите комуникират помежду си."
            }
        ]
    },
    {
        "questionNumber": 3,
        "question": "Какво представлява концепцията 'Polyglot persistence' в контекста на микросървисите?",
        "hint": "Думата 'persistence' се отнася до съхранението на данни. Как това се свързва с разнообразието от технологии?",
        "answerOptions": [
            {
                "text": "Възможността всяка услуга да бъде написана на различен език за програмиране.",
                "isCorrect": false,
                "rationale": "Това се нарича 'Polyglot programming' или 'Polyglot frameworks', а не 'Polyglot persistence'."
            },
            {
                "text": "Използването на централизирана база данни, която поддържа множество езици за заявки.",
                "isCorrect": false,
                "rationale": "Микросървисите насърчават децентрализацията на данните, а не използването на една обща база."
            },
            {
                "text": "Възможността всяка микроуслуга да използва най-подходящия за нейните нужди тип база данни.",
                "isCorrect": true,
                "rationale": "Това позволява гъвкавост и оптимизация, като се избира правилният инструмент (база данни) за конкретната задача."
            },
            {
                "text": "Стандарт за комуникация между различни типове бази данни.",
                "isCorrect": false,
                "rationale": "Концепцията се фокусира върху избора на база данни за всяка услуга, а не върху директната комуникация между самите бази данни."
            }
        ]
    },
    {
        "questionNumber": 4,
        "question": "Коя от изброените технологии най-често се използва за реализация на API Gateway?",
        "hint": "Потърсете специализирани инструменти, чиято основна цел е да служат като входна точка за API заявки.",
        "answerOptions": [
            {
                "text": "Docker",
                "isCorrect": false,
                "rationale": "Docker е платформа за контейнеризация, а не специализиран инструмент за управление на API."
            },
            {
                "text": "Kubernetes",
                "isCorrect": false,
                "rationale": "Kubernetes е оркестратор на контейнери, който може да управлява мрежовия трафик, но API Gateway е по-специфична функционалност."
            },
            {
                "text": "Amazon S3",
                "isCorrect": false,
                "rationale": "Amazon S3 е услуга за съхранение на обекти, а не за управление на API заявки."
            },
            {
                "text": "Kong",
                "isCorrect": true,
                "rationale": "Kong е популярна open-source платформа, специално създадена да действа като API Gateway."
            }
        ]
    },
    {
        "questionNumber": 5,
        "question": "Какво е основното предимство на контейнерите пред виртуалните машини (VMs)?",
        "hint": "Помислете на какво ниво се случва виртуализацията при двата подхода.",
        "answerOptions": [
            {
                "text": "Осигуряват по-силна изолация между приложенията.",
                "isCorrect": false,
                "rationale": "Виртуалните машини осигуряват по-силна изолация, тъй като всяка има собствено ядро на операционната система."
            },
            {
                "text": "Споделят ядрото на хостовата операционна система, което ги прави по-леки и бързи.",
                "isCorrect": true,
                "rationale": "Това е ключовата разлика, която води до по-ефективно използване на ресурсите и почти моментално стартиране."
            },
            {
                "text": "Могат да изпълняват различни операционни системи на един и същ хост.",
                "isCorrect": false,
                "rationale": "Това е характеристика на виртуалните машини, докато контейнерите споделят ядрото на една и съща хостова ОС."
            },
            {
                "text": "Абстрахират хардуера на машината.",
                "isCorrect": false,
                "rationale": "Абстракцията на хардуера е основната функция на хипервайзора при виртуалните машини."
            }
        ]
    },
    {
        "questionNumber": 6,
        "question": "Кой компонент НЕ е част от вътрешната структура на един микросървис?",
        "hint": "Припомнете си трите основни, изолирани компонента, които изграждат една микроуслуга.",
        "answerOptions": [
            {
                "text": "Application Logic",
                "isCorrect": false,
                "rationale": "Това е ядрото на услугата, съдържащо бизнес логиката."
            },
            {
                "text": "Data Store",
                "isCorrect": false,
                "rationale": "Всяка услуга управлява собствена, изолирана база данни."
            },
            {
                "text": "Public API",
                "isCorrect": false,
                "rationale": "Това е интерфейсът за комуникация с други услуги."
            },
            {
                "text": "Shared Kernel",
                "isCorrect": true,
                "rationale": "Споделеното ядро (Shared Kernel) е модел от Domain-Driven Design, който предполага споделяне на код между различни контексти, което е анти-модел в чистата микросървисна архитектура."
            }
        ]
    },
    {
        "questionNumber": 7,
        "question": "Какво означава SLA (Service Level Agreement) в контекста на принципа 'Be a good citizen'?",
        "hint": "Този документ определя очакванията за производителност и надеждност на услугата.",
        "answerOptions": [
            {
                "text": "Споразумение за нивото на сигурност, което услугата предоставя.",
                "isCorrect": false,
                "rationale": "Сигурността е важна, но SLA се фокусира върху производителността и достъпността."
            },
            {
                "text": "Дефиниция на възможностите и гаранциите за производителност, които една услуга предоставя.",
                "isCorrect": true,
                "rationale": "SLA включва метрики като очаквано натоварване (TPS), латентност и достъпност (availability)."
            },
            {
                "text": "Лицензионно споразумение за използване на софтуера на услугата.",
                "isCorrect": false,
                "rationale": "SLA е техническо, а не юридическо споразумение за ползване."
            },
            {
                "text": "Протокол за комуникация между услугите в екосистемата.",
                "isCorrect": false,
                "rationale": "SLA описва 'какво' се гарантира, а не 'как' се осъществява комуникацията."
            }
        ]
    },
    {
        "questionNumber": 8,
        "question": "Коя от следните стратегии за сигурност включва прилагането на множество независими слоя на защита?",
        "hint": "Името на тази стратегия подсказва за изграждане на защита в 'дълбочина'.",
        "answerOptions": [
            {
                "text": "API Throttling",
                "isCorrect": false,
                "rationale": "Това е техника за ограничаване на броя заявки, която е само един от слоевете на защита."
            },
            {
                "text": "Secret Management",
                "isCorrect": false,
                "rationale": "Това е практиката за сигурно съхранение на чувствителна информация, което е един компонент от общата стратегия."
            },
            {
                "text": "Defense in Depth",
                "isCorrect": true,
                "rationale": "Тази стратегия разчита, че ако един защитен слой бъде пробит, другите ще продължат да предпазват системата."
            },
            {
                "text": "Authentication",
                "isCorrect": false,
                "rationale": "Автентикацията е процесът на доказване на самоличност и е само един от защитните механизми."
            }
        ]
    },
    {
        "questionNumber": 9,
        "question": "Какъв е основният проблем, който контейнерите решават в процеса на разработка и внедряване?",
        "hint": "Помислете за консистентността на средата за изпълнение.",
        "answerOptions": [
            {
                "text": "Необходимостта от по-мощен хардуер.",
                "isCorrect": false,
                "rationale": "Контейнерите са леки и оптимизират използването на ресурси, не изискват по-мощен хардуер."
            },
            {
                "text": "Проблемът 'работи на моята машина, но не и в продукция' поради разлики в средите.",
                "isCorrect": true,
                "rationale": "Като пакетират приложението и всичките му зависимости, контейнерите гарантират консистентност навсякъде."
            },
            {
                "text": "Бавното компилиране на кода.",
                "isCorrect": false,
                "rationale": "Контейнерите се занимават с пакетиране и изпълнение, а не със скоростта на компилация."
            },
            {
                "text": "Липсата на достатъчно програмни езици.",
                "isCorrect": false,
                "rationale": "Контейнерите са независими от програмния език."
            }
        ]
    },
    {
        "questionNumber": 10,
        "question": "Коя AWS услуга се използва за автоматизирано внедряване на код в различни среди (development, staging, production)?",
        "hint": "Името на услугата директно описва нейната основна функция, свързана с внедряването.",
        "answerOptions": [
            {
                "text": "AWS CodeCommit",
                "isCorrect": false,
                "rationale": "CodeCommit е Git-базирано хранилище за код, подобно на GitHub."
            },
            {
                "text": "AWS CodePipeline",
                "isCorrect": false,
                "rationale": "CodePipeline оркестрира целия CI/CD процес, но самото внедряване се извършва от друга услуга."
            },
            {
                "text": "AWS CodeDeploy",
                "isCorrect": true,
                "rationale": "Както подсказва името, тази услуга е специализирана в автоматизирането на процеса на внедряване (deployment)."
            },
            {
                "text": "AWS Secrets Manager",
                "isCorrect": false,
                "rationale": "Тази услуга е за управление на чувствителна информация, а не за внедряване на код."
            }
        ]
    },
    {
        "questionNumber": 11,
        "question": "Какъв тип комуникация се осъществява, когато една услуга извиква API на друга и чака за отговор, преди да продължи?",
        "hint": "Помислете дали извикващата услуга е 'блокирана' по време на заявката.",
        "answerOptions": [
            {
                "text": "Асинхронна комуникация",
                "isCorrect": false,
                "rationale": "При асинхронната комуникация извикващата услуга не чака за отговор и може да продължи работата си."
            },
            {
                "text": "Синхронна комуникация",
                "isCorrect": true,
                "rationale": "Това е класическият модел на заявка-отговор (request-response), където извикващият е блокиран до получаване на отговор."
            },
            {
                "text": "Комуникация, базирана на събития (Event-driven)",
                "isCorrect": false,
                "rationale": "При този модел услугите комуникират чрез изпращане и получаване на събития, което е форма на асинхронна комуникация."
            },
            {
                "text": "Пакетна комуникация",
                "isCorrect": false,
                "rationale": "Пакетната обработка се отнася до обработка на големи обеми данни наведнъж, а не до модела на комуникация в реално време."
            }
        ]
    },
    {
        "questionNumber": 12,
        "question": "Кой от следните модели НЕ е често срещан за реализиране на асинхронна комуникация между микросървиси?",
        "hint": "Кой от изброените протоколи по своята същност следва модела 'заявка-отговор'?",
        "answerOptions": [
            {
                "text": "Message Queue (напр. RabbitMQ, SQS)",
                "isCorrect": false,
                "rationale": "Системите за съобщения са основен инструмент за изграждане на асинхронна и слабо свързана комуникация."
            },
            {
                "text": "REST API přes HTTP",
                "isCorrect": true,
                "rationale": "REST přes HTTP е по своята същност синхронен протокол (заявка-отговор), въпреки че може да се симулира асинхронност с техники като webhooks."
            },
            {
                "text": "Publish/Subscribe (напр. Kafka, SNS)",
                "isCorrect": false,
                "rationale": "Този модел позволява на една услуга да публикува събитие, без да знае кои други услуги ще го консумират, което е ключово за асинхронната комуникация."
            },
            {
                "text": "Webhooks",
                "isCorrect": false,
                "rationale": "Webhooks са механизъм, при който една система уведомява друга за събитие чрез HTTP POST заявка, което е асинхронен модел."
            }
        ]
    },
    {
        "questionNumber": 13,
        "question": "Какво представлява 'разпределеното проследяване' (distributed tracing) в контекста на наблюдаемостта?",
        "hint": "Как можете да проследите една-единствена потребителска заявка, докато тя преминава през множество различни услуги?",
        "answerOptions": [
            {
                "text": "Проследяване на физическото местоположение на сървърите.",
                "isCorrect": false,
                "rationale": "Това се отнася до управление на инфраструктурата, а не до проследяване на заявки."
            },
            {
                "text": "Събиране на логове от всички услуги на едно централизирано място.",
                "isCorrect": false,
                "rationale": "Това се нарича централизирано логиране (centralized logging) и е част от наблюдаемостта, но не е същото като разпределеното проследяване."
            },
            {
                "text": "Присвояване на уникално ID на всяка заявка, което се предава през всички услуги, за да се проследи нейният път.",
                "isCorrect": true,
                "rationale": "Това позволява да се види пълният път на една заявка, времето, прекарано във всяка услуга, и да се идентифицират тесните места (bottlenecks)."
            },
            {
                "text": "Измерване на основни метрики като CPU и RAM за всяка услуга.",
                "isCorrect": false,
                "rationale": "Това е мониторинг на ресурсите, който е важен, но различен от проследяването на пътя на заявката."
            }
        ]
    },
    {
        "questionNumber": 14,
        "question": "Каква е ролята на 'Container Engine' като Docker?",
        "hint": "Помислете какво прави Docker на една-единствена машина.",
        "answerOptions": [
            {
                "text": "Да емулира физически хардуер.",
                "isCorrect": false,
                "rationale": "Това е ролята на хипервайзора при виртуалните машини."
            },
            {
                "text": "Да управлява жизнения цикъл на контейнерите и да осигури изолация между тях.",
                "isCorrect": true,
                "rationale": "Docker Engine е отговорен за създаването, стартирането, спирането и управлението на контейнери върху хостовата операционна система."
            },
            {
                "text": "Да пише автоматично Dockerfile файлове.",
                "isCorrect": false,
                "rationale": "Dockerfile е текстов файл с инструкции, който се пише от разработчиците, а не се генерира автоматично от енджина."
            },
            {
                "text": "Да управлява клъстери от множество машини.",
                "isCorrect": false,
                "rationale": "Управлението на контейнери в клъстер е задача за оркестратори като Kubernetes или Docker Swarm."
            }
        ]
    },
    {
        "questionNumber": 15,
        "question": "Каква е разликата между автентикация и оторизация?",
        "hint": "Единият процес идва преди другия. Първо трябва да знаеш кой е потребителят, преди да решиш какво може да прави.",
        "answerOptions": [
            {
                "text": "Няма разлика, това са два термина за едно и също нещо.",
                "isCorrect": false,
                "rationale": "Това са два различни, макар и свързани, процеса в сигурността."
            },
            {
                "text": "Автентикацията е процесът на криптиране на данни, а оторизацията е процесът на декриптиране.",
                "isCorrect": false,
                "rationale": "Криптирането и декриптирането са свързани със защита на данните в покой или при пренос, а не с управлението на достъпа."
            },
            {
                "text": "Автентикацията проверява 'кой си ти?', а оторизацията проверява 'какво ти е позволено да правиш?'.",
                "isCorrect": true,
                "rationale": "Автентикацията е доказване на самоличност (напр. с парола), докато оторизацията е проверка на правата за достъп до ресурс след успешна автентикация."
            },
            {
                "text": "Автентикацията се случва на ниво API Gateway, а оторизацията се случва в самата микроуслуга.",
                "isCorrect": false,
                "rationale": "И двата процеса могат да се управляват както централизирано (напр. в API Gateway), така и локално във всяка услуга."
            }
        ]
    },
    {
        "questionNumber": 16,
        "question": "Кой от изброените е недостатък на микросървисната архитектура в сравнение с монолитната?",
        "hint": "Помислете за предизвикателствата при управлението на много на брой движещи се части.",
        "answerOptions": [
            {
                "text": "По-трудно мащабиране.",
                "isCorrect": false,
                "rationale": "Микросървисите позволяват ефективно и гранулирано мащабиране само на натоварените услуги, което е предимство."
            },
            {
                "text": "По-бавна паралелна разработка.",
                "isCorrect": false,
                "rationale": "Независимостта на услугите позволява на различни екипи да работят паралелно, което ускорява разработката."
            },
            {
                "text": "По-голяма операционна сложност.",
                "isCorrect": true,
                "rationale": "Управлението, наблюдението и осигуряването на десетки или стотици независими услуги е значително по-сложно от управлението на един монолит."
            },
            {
                "text": "По-малка устойчивост на грешки (resilience).",
                "isCorrect": false,
                "rationale": "Срив в една услуга обикновекновено не засяга цялата система, което прави архитектурата по-устойчива, а не по-малко."
            }
        ]
    },
    {
        "questionNumber": 17,
        "question": "Какво е 'IaC' (Infrastructure as Code)?",
        "hint": "Тази практика третира конфигурацията на сървъри, мрежи и бази данни по същия начин, както се третира кодът на приложението.",
        "answerOptions": [
            {
                "text": "Писане на код, който директно управлява хардуерни компоненти.",
                "isCorrect": false,
                "rationale": "Това е по-скоро свързано с embedded програмиране, а не с управление на облачна инфраструктура."
            },
            {
                "text": "Процесът на управление и провизиране на компютърна инфраструктура чрез машинно-четими дефиниционни файлове.",
                "isCorrect": true,
                "rationale": "Това позволява автоматизирано, повтаряемо и версионирано създаване на инфраструктура, използвайки инструменти като Terraform или AWS CloudFormation."
            },
            {
                "text": "Библиотека за работа с мрежови протоколи.",
                "isCorrect": false,
                "rationale": "IaC е концепция и набор от инструменти, а не специфична библиотека."
            },
            {
                "text": "Автоматизирано тестване на инфраструктурата.",
                "isCorrect": false,
                "rationale": "Тестването е част от процеса, но IaC обхваща цялостното управление и създаване на инфраструктурата чрез код."
            }
        ]
    },
    {
        "questionNumber": 18,
        "question": "Защо семантичното версиониране (Semantic Versioning) е важно за публичните API-та на микросървисите?",
        "hint": "Помислете как промените в API-то на една услуга могат да засегнат другите услуги, които я използват.",
        "answerOptions": [
            {
                "text": "За да се гарантира, че API-то е напълно сигурно.",
                "isCorrect": false,
                "rationale": "Версионирането не е пряко свързано със сигурността, а с управлението на промените."
            },
            {
                "text": "За да се намали латентността на мрежовите заявки.",
                "isCorrect": false,
                "rationale": "Версията на API-то не влияе на скоростта на мрежата."
            },
            {
                "text": "За да се комуникира ясно на клиентите какви промени са направени и дали те са съвместими назад.",
                "isCorrect": true,
                "rationale": "Форматът MAJOR.MINOR.PATCH позволява на потребителите на API-то да разберат дали една нова версия ще 'счупи' тяхната интеграция."
            },
            {
                "text": "За да се автоматизира процесът на внедряване.",
                "isCorrect": false,
                "rationale": "Автоматизацията е важна, но версионирането е насочено към комуникацията на промените, а не към самия процес на внедряване."
            }
        ]
    },
    {
        "questionNumber": 19,
        "question": "Кой от следните е пример за 'Secret Management' система?",
        "hint": "Търсете инструмент, чиято основна цел е да действа като 'трезор' за чувствителна информация.",
        "answerOptions": [
            {
                "text": "Git",
                "isCorrect": false,
                "rationale": "Git е система за контрол на версиите. Съхраняването на чувствителна информация в Git е силно непрепоръчително."
            },
            {
                "text": "Jenkins",
                "isCorrect": false,
                "rationale": "Jenkins е сървър за автоматизация, използван за CI/CD, но не е специализиран в сигурното съхранение на тайни."
            },
            {
                "text": "HashiCorp Vault",
                "isCorrect": true,
                "rationale": "Vault е един от най-популярните инструменти, специално създаден за сигурно съхранение и управление на достъпа до тайни като API ключове, пароли и сертификати."
            },
            {
                "text": "Prometheus",
                "isCorrect": false,
                "rationale": "Prometheus е система за мониторинг и алармиране, а не за управление на тайни."
            }
        ]
    },
    {
        "questionNumber": 20,
        "question": "Какъв е смисълът на принципа 'It's more than just technology transformation'?",
        "hint": "Помислете за връзката между начина, по който екипите са организирани, и софтуера, който те създават.",
        "answerOptions": [
            {
                "text": "Преминаването към микросървиси изисква използването на най-новите технологии.",
                "isCorrect": false,
                "rationale": "Въпреки че новите технологии са полезни, този принцип набляга на организационни, а не на чисто технологични промени."
            },
            {
                "text": "Успешната микросървисна архитектура изисква промяна в структурата на екипите и културата на работа.",
                "isCorrect": true,
                "rationale": "Този принцип, често свързван със 'Закона на Конуей', гласи, че архитектурата на софтуера трябва да отразява комуникационната структура на организацията (малки, автономни екипи)."
            },
            {
                "text": "Трябва да се автоматизират не само технологиите, но и бизнес процесите.",
                "isCorrect": false,
                "rationale": "Това е вярно, но принципът се фокусира конкретно върху връзката между софтуерната архитектура и организационната структура."
            },
            {
                "text": "Микросървисите са по-скъпи за поддръжка от монолитите.",
                "isCorrect": false,
                "rationale": "Въпреки че може да има по-високи операционни разходи, този принцип не се отнася до финансовия аспект."
            }
        ]
    },
    {
        "questionNumber": 21,
        "question": "Кое е основното ниво на абстракция при контейнерите?",
        "hint": "Какво споделят всички контейнери, работещи на една хост машина?",
        "answerOptions": [
            {
                "text": "Хардуер",
                "isCorrect": false,
                "rationale": "Хардуерът се абстрахира от виртуалните машини чрез хипервайзор."
            },
            {
                "text": "Операционна система",
                "isCorrect": true,
                "rationale": "Контейнерите виртуализират операционната система, позволявайки на множество изолирани процеси да споделят едно и също ядро."
            },
            {
                "text": "Приложение",
                "isCorrect": false,
                "rationale": "Приложението работи вътре в контейнера; самият контейнер е абстракцията."
            },
            {
                "text": "Мрежа",
                "isCorrect": false,
                "rationale": "Мрежата е един от ресурсите, които се управляват, но основната абстракция е на ниво ОС."
            }
        ]
    },
    {
        "questionNumber": 22,
        "question": "Какво представлява Docker Image?",
        "hint": "Каква е разликата между 'клас' и 'обект' в обектно-ориентираното програмиране? Тук аналогията е подобна.",
        "answerOptions": [
            {
                "text": "Изпълняващ се екземпляр на контейнер.",
                "isCorrect": false,
                "rationale": "Това е дефиницията за контейнер (container). Имиджът е шаблонът, а контейнерът е инстанцията."
            },
            {
                "text": "Текстов файл с инструкции за създаване на контейнер.",
                "isCorrect": false,
                "rationale": "Това е дефиницията за Dockerfile."
            },
            {
                "text": "Непроменяем, статичен шаблон, който съдържа всичко необходимо за стартиране на приложението.",
                "isCorrect": true,
                "rationale": "Имиджът е read-only пакет, съдържащ кода на приложението, библиотеки, зависимости и конфигурация. Контейнерите се създават от имиджи."
            },
            {
                "text": "Виртуално дисково пространство, използвано от контейнер.",
                "isCorrect": false,
                "rationale": "Това се нарича 'volume' и се използва за персистентност на данните."
            }
        ]
    },
    {
        "questionNumber": 23,
        "question": "Кой инструмент се използва за оркестрация на контейнери в голям мащаб?",
        "hint": "Търсете система, която управлява контейнери, разпределени на множество сървъри (нодове).",
        "answerOptions": [
            {
                "text": "Docker Compose",
                "isCorrect": false,
                "rationale": "Docker Compose е инструмент за дефиниране и стартиране на многоконтейнерни приложения на една-единствена машина, но не е предназначен за управление на клъстери."
            },
            {
                "text": "Kubernetes",
                "isCorrect": true,
                "rationale": "Kubernetes е де факто стандартът за автоматизиране на внедряването, мащабирането и управлението на контейнеризирани приложения в клъстерна среда."
            },
            {
                "text": "Dockerfile",
                "isCorrect": false,
                "rationale": "Dockerfile се използва за изграждане на единичен Docker имидж, а не за управление на множество контейнери."
            },
            {
                "text": "Git",
                "isCorrect": false,
                "rationale": "Git е система за контрол на версиите на кода."
            }
        ]
    },
    {
        "questionNumber": 24,
        "question": "Какво е предимството на 'декларативния' подход в инструменти като Kubernetes и Terraform?",
        "hint": "Вместо да давате команди стъпка по стъпка, вие описвате какъв искате да бъде крайният резултат.",
        "answerOptions": [
            {
                "text": "Дава по-фина настройка върху всяка стъпка от процеса.",
                "isCorrect": false,
                "rationale": "Това е характеристика на 'императивния' подход, където описвате стъпките 'как' да се постигне нещо."
            },
            {
                "text": "Описва желаното крайно състояние на системата, а инструментът се грижи как да го постигне.",
                "isCorrect": true,
                "rationale": "При декларативния подход вие описвате 'какво' искате (напр. 3 реплики на приложението), а системата сама разбира как да достигне до това състояние."
            },
            {
                "text": "Изпълнява се по-бързо от императивния подход.",
                "isCorrect": false,
                "rationale": "Скоростта не е основното предимство; надеждността и предвидимостта са по-важни."
            },
            {
                "text": "По-лесен е за начинаещи, тъй като не изисква писане на код.",
                "isCorrect": false,
                "rationale": "Въпреки че е по-абстрактен, той все още изисква писане на конфигурационни файлове (код), които могат да бъде сложни."
            }
        ]
    },
    {
        "questionNumber": 25,
        "question": "Кой от следните проблеми е свързан с управлението на данни в микросървисна архитектура?",
        "hint": "Какво се случва, когато една бизнес операция трябва да промени данни в две различни, независими бази данни едновременно?",
        "answerOptions": [
            {
                "text": "ACID транзакции",
                "isCorrect": true,
                "rationale": "Тъй като всяка услуга има собствена база данни, гарантирането на консистентност (като при ACID транзакции) в операции, обхващащи няколко услуги, е голямо предизвикателство."
            },
            {
                "text": "Липса на подходящи бази данни",
                "isCorrect": false,
                "rationale": "Напротив, 'Polyglot persistence' позволява избора от голямо разнообразие от бази данни."
            },
            {
                "text": "Твърде много данни за съхранение",
                "isCorrect": false,
                "rationale": "Обемът на данните е проблем независимо от архитектурата."
            },
            {
                "text": "Бавен достъп до данните",
                "isCorrect": false,
                "rationale": "Чрез избора на правилната база данни за всяка услуга достъпът може да бъде силно оптимизиран."
            }
        ]
    },
    {
        "questionNumber": 26,
        "question": "Какво представлява моделът 'Saga' в микросървисите?",
        "hint": "Този модел е решение на проблема с разпределените транзакции, като осигурява консистентност без заключване на ресурси.",
        "answerOptions": [
            {
                "text": "Начин за сигурно съхранение на конфигурация.",
                "isCorrect": false,
                "rationale": "Това се постига чрез системи за secret management."
            },
            {
                "text": "Механизъм за управление на дълготрайни транзакции, които обхващат няколко услуги.",
                "isCorrect": true,
                "rationale": "Saga управлява поредица от локални транзакции. Ако някоя стъпка се провали, се изпълняват компенсиращи транзакции, за да се отмени вече извършеното."
            },
            {
                "text": "Библиотека за по-бърза мрежова комуникация.",
                "isCorrect": false,
                "rationale": "Saga е архитектурен модел, а не специфична библиотека."
            },
            {
                "text": "Стандарт за версиониране на API.",
                "isCorrect": false,
                "rationale": "За версиониране се използва семантично версиониране."
            }
        ]
    },
    {
        "questionNumber": 27,
        "question": "Коя характеристика на микросървисната архитектура най-пряко допринася за технологичната независимост?",
        "hint": "Кое свойство позволява на един екип да избере Python за своята услуга, докато друг екип избира Go, без това да създава конфликт?",
        "answerOptions": [
            {
                "text": "Слаба свързаност",
                "isCorrect": true,
                "rationale": "Слабата свързаност позволява на услугите да еволюират независимо, което включва и избор на различни технологии."
            },
            {
                "text": "Независимо внедряване",
                "isCorrect": false,
                "rationale": "Това е резултат от технологичната независимост, а не нейната първопричина."
            },
            {
                "text": "Устойчивост",
                "isCorrect": false,
                "rationale": "Устойчивостта е свързана с изолацията на грешки, а не пряко с избора на технологии."
            },
            {
                "text": "Ефективно мащабиране",
                "isCorrect": false,
                "rationale": "Мащабирането е свързано с управлението на ресурсите, а не с технологичния стак."
            }
        ]
    },
    {
        "questionNumber": 28,
        "question": "Каква е целта на 'rate limiting' (API throttling) в API Gateway?",
        "hint": "Помислете как можете да спрете клиент, който изпраща хиляди заявки в секунда.",
        "answerOptions": [
            {
                "text": "Да се гарантира, че само оторизирани потребители имат достъп.",
                "isCorrect": false,
                "rationale": "Това е целта на оторизацията."
            },
            {
                "text": "Да се предпазят услугите от претоварване и DDoS атаки.",
                "isCorrect": true,
                "rationale": "Чрез ограничаване на броя заявки за определен период от време се предотвратява злонамерено или случайно претоварване на бекенд услугите."
            },
            {
                "text": "Да се ускори времето за отговор на заявките.",
                "isCorrect": false,
                "rationale": "Rate limiting може леко да забави заявките, тъй като добавя допълнителна проверка, но основната му цел е защита."
            },
            {
                "text": "Да се събират метрики за използването на API.",
                "isCorrect": false,
                "rationale": "Събирането на метрики е страничен продукт, но основната цел е контрол и защита."
            }
        ]
    },
    {
        "questionNumber": 29,
        "question": "Какво означава един контейнер да е 'непроменяем' (immutable)?",
        "hint": "Вместо да 'ремонтирате' работеща кола, вие я заменяте с изцяло нова.",
        "answerOptions": [
            {
                "text": "Че не може да бъде изтрит, след като е създаден.",
                "isCorrect": false,
                "rationale": "Контейнерите могат да бъдат спирани и изтривани."
            },
            {
                "text": "Че след като бъде стартиран, неговото състояние и код не се променят; за промяна се създава нов контейнер.",
                "isCorrect": true,
                "rationale": "Принципът на непроменяемата инфраструктура гласи, че вместо да се променя работещ компонент, той се заменя с нова, актуализирана версия. Това води до по-голяма предвидимост и по-малко грешки."
            },
            {
                "text": "Че не може да записва данни на диск.",
                "isCorrect": false,
                "rationale": "Контейнерите могат да записват данни, но тези данни са ефимерни (изчезват със спирането на контейнера), освен ако не се използват 'volumes'."
            },
            {
                "text": "Че използва само статично компилирани езици.",
                "isCorrect": false,
                "rationale": "Непроменяемостта е концепция на ниво инфраструктура, а не е свързана с типа на програмния език."
            }
        ]
    },
    {
        "questionNumber": 30,
        "question": "Кой етап от CI/CD процеса се задейства автоматично след 'commit' на код в хранилището?",
        "hint": "Какво трябва да се направи първо, за да се провери дали новите промени са коректни?",
        "answerOptions": [
            {
                "text": "Внедряване в продукция (Deployment)",
                "isCorrect": false,
                "rationale": "Внедряването е последната стъпка и обикновено изисква преминаването на всички предходни етапи."
            },
            {
                "text": "Ръчно одобрение (Manual Approval)",
                "isCorrect": false,
                "rationale": "Ръчното одобрение е стъпка, която може да се случи по-късно в процеса, обикновекновено преди внедряване в продукция."
            },
            {
                "text": "Изграждане и тестване (Build & Test)",
                "isCorrect": true,
                "rationale": "Това е първата автоматизирана стъпка, при която кодът се компилира (ако е необходимо) и се изпълняват автоматизирани тестове, за да се гарантира, че промяната не е въвела регресии."
            },
            {
                "text": "Мониторинг и алармиране (Monitoring & Alerting)",
                "isCorrect": false,
                "rationale": "Мониторингът се случва след като кодът е внедрен и работи в дадена среда."
            }
        ]
    },
    {
        "questionNumber": 31,
        "question": "Коя от следните не е техническа характеристика на монолитната архитектура?",
        "hint": "Коя характеристика описва разнообразието от технологии, а не хомогенността?",
        "answerOptions": [
            {
                "text": "Единна кодова база",
                "isCorrect": false,
                "rationale": "При монолита целият код се намира в едно хранилище и се управлява като едно цяло."
            },
            {
                "text": "Полиглотна архитектура",
                "isCorrect": true,
                "rationale": "Това е характеристика на микросървисите, позволяваща използването на различни технологии. Монолитите обикновено са изградени с една технология."
            },
            {
                "text": "Единствен артефакт за внедряване",
                "isCorrect": false,
                "rationale": "Цялото приложение се компилира и пакетира в един-единствен файл (напр. WAR, JAR, EXE)."
            },
            {
                "text": "Споделяне на ресурси в един процес",
                "isCorrect": false,
                "rationale": "Всички компоненти се изпълняват в рамките на един и същ процес и споделят CPU и RAM."
            }
        ]
    },
    {
        "questionNumber": 32,
        "question": "Кой е основният механизъм за комуникация между микросървисите?",
        "hint": "Помислете как два отделни процеса, които може да са на различни машини, могат да си говорят.",
        "answerOptions": [
            {
                "text": "Директно извикване на методи в паметта",
                "isCorrect": false,
                "rationale": "Това е типично за монолитната архитектура, където компонентите са в един процес."
            },
            {
                "text": "Споделяне на обща база данни",
                "isCorrect": false,
                "rationale": "Това е анти-модел, който създава силна свързаност и нарушава принципа за независимост на данните."
            },
            {
                "text": "Комуникация през мрежата чрез API-та",
                "isCorrect": true,
                "rationale": "Тъй като услугите се изпълняват в отделни процеси, те трябва да комуникират през мрежата, използвайки добре дефинирани интерфейси."
            },
            {
                "text": "Четене и запис във файловата система",
                "isCorrect": false,
                "rationale": "Това е неефективен и ненадежден начин за комуникация между разпределени услуги."
            }
        ]
    },
    {
        "questionNumber": 33,
        "question": "Кое от изброените НЕ е предимство на микросървисната архитектура?",
        "hint": "Кой аспект става по-сложен, когато трябва да координирате множество отделни части?",
        "answerOptions": [
            {
                "text": "Устойчивост на грешки",
                "isCorrect": false,
                "rationale": "Изолацията на услугите означава, че срив в една от тях не събаря цялата система."
            },
            {
                "text": "Леснота на тестване от край до край (end-to-end)",
                "isCorrect": true,
                "rationale": "Тестването на бизнес процес, който преминава през множество независими услуги, е значително по-сложно, отколкото тестването на монолитно приложение."
            },
            {
                "text": "Паралелна разработка от различни екипи",
                "isCorrect": false,
                "rationale": "Независимостта на услугите позволява на екипите да работят едновременно без да си пречат."
            },
            {
                "text": "Ефективно мащабиране",
                "isCorrect": false,
                "rationale": "Вместо да се мащабира цялото приложение, могат да се добавят ресурси само за най-натоварените услуги."
            }
        ]
    },
    {
        "questionNumber": 34,
        "question": "Кой принцип на микросървисите е най-тясно свързан с енкапсулацията?",
        "hint": "Кой принцип създава 'черна кутия', където вътрешните детайли са скрити и достъпът е само през дефиниран интерфейс?",
        "answerOptions": [
            {
                "text": "Use the right tool for the job",
                "isCorrect": false,
                "rationale": "Този принцип е за технологичната свобода, а не за скриването на имплементацията."
            },
            {
                "text": "Automate everything",
                "isCorrect": false,
                "rationale": "Този принцип се отнася до процесите, а не до дизайна на комуникацията."
            },
            {
                "text": "Rely only on the public API",
                "isCorrect": true,
                "rationale": "Като се забранява директният достъп до вътрешните компоненти (като базата данни) и се налага комуникация само през API, се постига енкапсулация - скриване на вътрешната имплементация."
            },
            {
                "text": "Secure your services",
                "isCorrect": false,
                "rationale": "Сигурността е свързана със защита, докато енкапсулацията е със скриване на сложността и детайлите."
            }
        ]
    },
    {
        "questionNumber": 35,
        "question": "Какво НЕ съдържа един контейнер?",
        "hint": "Кое е най-'тежкото' нещо, което виртуалните машини имат, а контейнерите - не?",
        "answerOptions": [
            {
                "text": "Кодът на приложението",
                "isCorrect": false,
                "rationale": "Това е основната част от съдържанието на контейнера."
            },
            {
                "text": "Зависимости и библиотеки",
                "isCorrect": false,
                "rationale": "Контейнерът пакетира всички необходими софтуерни компоненти, за да работи приложението."
            },
            {
                "text": "Пълна гост операционна система с ядро",
                "isCorrect": true,
                "rationale": "Това е характеристика на виртуалните машини. Контейнерите споделят ядрото на хостовата ОС и не включват собствено."
            },
            {
                "text": "Конфигурационни файлове",
                "isCorrect": false,
                "rationale": "Конфигурацията, необходима за стартиране на приложението, също е част от пакета."
            }
        ]
    },
    {
        "questionNumber": 36,
        "question": "Кой от следните е пример за 'Polyglot frameworks'?",
        "hint": "Думата 'frameworks' тук се отнася до езиците за програмиране и техните екосистеми.",
        "answerOptions": [
            {
                "text": "Използване на MySQL и MongoDB в една и съща система.",
                "isCorrect": false,
                "rationale": "Това е пример за 'Polyglot persistence'."
            },
            {
                "text": "Услуга за поръчки, написана на Java, и услуга за нотификации, написана на Python.",
                "isCorrect": true,
                "rationale": "Това показва използването на различни езици и фреймуърци за различните услуги в рамките на една система."
            },
            {
                "text": "Цяло приложение, написано само на .NET Core.",
                "isCorrect": false,
                "rationale": "Това е пример за хомогенна технологична среда, типична за монолитите."
            },
            {
                "text": "Комуникация между услуги чрез gRPC и REST.",
                "isCorrect": false,
                "rationale": "Това се отнася до протоколите за комуникация, а не до фреймуърците, с които са изградени услугите."
            }
        ]
    },
    {
        "questionNumber": 37,
        "question": "Каква е основната разлика в консумацията на ресурси между VM и контейнер?",
        "hint": "Помислете за 'overhead'-а, който всяка технология добавя.",
        "answerOptions": [
            {
                "text": "Контейнерите консумират повече CPU, но по-малко RAM.",
                "isCorrect": false,
                "rationale": "Контейнерите са по-леки и консумират по-малко както CPU, така и RAM."
            },
            {
                "text": "VMs са много по-тежки, защото всяка има собствена ОС, докато контейнерите споделят една ОС.",
                "isCorrect": true,
                "rationale": "Липсата на пълна гост ОС във всеки контейнер води до значително по-ниска консумация на ресурси (CPU, RAM, дисково пространство)."
            },
            {
                "text": "Няма съществена разлика в консумацията на ресурси.",
                "isCorrect": false,
                "rationale": "Разликата е фундаментална и е едно от основните предимства на контейнерите."
            },
            {
                "text": "VMs са по-ефективни при управлението на дисковото пространство.",
                "isCorrect": false,
                "rationale": "Контейнерите, поради своята слоеста файлова система, са по-ефективни при управлението на дисково пространство, особено когато няколко контейнера споделят общи слоеве."
            }
        ]
    },
    {
        "questionNumber": 38,
        "question": "Кой аспект на наблюдаемостта (observability) помага да се разбере как производителността на услугата влияе на крайния потребител?",
        "hint": "Къде се случва реалното взаимодействие с потребителя - в бекенд услугите или в браузъра/мобилното приложение?",
        "answerOptions": [
            {
                "text": "Споделени метрики (Shared metrics)",
                "isCorrect": false,
                "rationale": "Тези метрики (напр. време за отговор) са технически, но не показват директно потребителското изживяване."
            },
            {
                "text": "Разпределено проследяване (Distributed tracing)",
                "isCorrect": false,
                "rationale": "Това е полезно за дебъгване на проблеми в бекенда, но не измерва директно потребителското преживяване."
            },
            {
                "text": "Централизирано логиране (Centralized logging)",
                "isCorrect": false,
                "rationale": "Логовете съдържат детайлна информация за събития, но анализът им за потребителско изживяване е труден."
            },
            {
                "text": "Метрики за потребителското изживяване (User experience metrics)",
                "isCorrect": true,
                "rationale": "Това включва събиране на данни от клиентската страна (front-end), като време за зареждане на страница, интерактивност и др., които пряко отразяват преживяването на потребителя."
            }
        ]
    },
    {
        "questionNumber": 39,
        "question": "Защо ръчното управление на десетки микросървиси е практически невъзможно?",
        "hint": "Помислете за разликата между това да се грижите за един домашен любимец и за сто.",
        "answerOptions": [
            {
                "text": "Защото изисква твърде много хардуерни ресурси.",
                "isCorrect": false,
                "rationale": "Проблемът не е в ресурсите, а в сложността на координацията."
            },
            {
                "text": "Защото сложността на зависимостите, внедряването и мониторинга нараства експоненциално с броя на услугите.",
                "isCorrect": true,
                "rationale": "Без автоматизация, задачи като внедряване на нова версия, конфигуриране, мащабиране и наблюдение на всяка услуга стават непосилни и податливи на грешки."
            },
            {
                "text": "Защото няма достатъчно квалифицирани специалисти.",
                "isCorrect": false,
                "rationale": "Въпреки че специалисти са нужни, основният проблем е мащабът на сложността, който надхвърля човешките възможности за ръчно управление."
            },
            {
                "text": "Защото мрежовата латентност става твърде голяма.",
                "isCorrect": false,
                "rationale": "Латентността е предизвикателство, но то не прави ръчното управление невъзможно, а по-скоро изисква добър дизайн. Сложността го прави невъзможно."
            }
        ]
    },
    {
        "questionNumber": 40,
        "question": "Кой е основният недостатък при стартирането на виртуална машина?",
        "hint": "Какво се случва, когато включите компютъра си? Виртуалната машина преминава през подобен процес.",
        "answerOptions": [
            {
                "text": "Ниско ниво на сигурност.",
                "isCorrect": false,
                "rationale": "Виртуалните машини предлагат много високо ниво на сигурност и изолация."
            },
            {
                "text": "Несъвместимост с облачни платформи.",
                "isCorrect": false,
                "rationale": "Облачните платформи са изградени основно върху виртуални машини."
            },
            {
                "text": "Бавно стартиране, отнемащо минути.",
                "isCorrect": true,
                "rationale": "Тъй като всяка VM трябва да зареди цяла операционна система, процесът на стартиране е значително по-бавен в сравнение с контейнерите."
            },
            {
                "text": "Малък капацитет за съхранение на данни.",
                "isCorrect": false,
                "rationale": "Капацитетът за съхранение може да бъде конфигуриран според нуждите и не е вроден недостатък."
            }
        ]
    },
    {
        "questionNumber": 41,
        "question": "Какъв е стандартният формат, използван от JWT (JSON Web Tokens) за представяне на информация за автентикация и оторизация?",
        "hint": "Името на технологията често дава подсказка за формата на данните, които използва.",
        "answerOptions": [
            {
                "text": "XML",
                "isCorrect": false,
                "rationale": "JWT използва JSON, както подсказва и името, а не XML."
            },
            {
                "text": "Base64 кодиран JSON",
                "isCorrect": true,
                "rationale": "JWT се състои от три части (Header, Payload, Signature), кодирани с Base64Url, като първите две са JSON обекти."
            },
            {
                "text": "Binary",
                "isCorrect": false,
                "rationale": "Въпреки че се предава като текст, вътрешната структура е базирана на JSON."
            },
            {
                "text": "YAML",
                "isCorrect": false,
                "rationale": "JWT спецификацията изрично използва JSON."
            }
        ]
    },
    {
        "questionNumber": 42,
        "question": "Какво представлява 'Service Discovery' в микросървисна среда?",
        "hint": "Как услуга А разбира на кой IP адрес работи услуга Б, ако този адрес може да се променя всеки момент?",
        "answerOptions": [
            {
                "text": "Процесът на откриване на грешки в услугите.",
                "isCorrect": false,
                "rationale": "Това се постига чрез мониторинг и алармиране."
            },
            {
                "text": "Процесът, чрез който една услуга намира мрежовото местоположение (IP адрес и порт) на друга услуга.",
                "isCorrect": true,
                "rationale": "В динамична среда, където инстанциите на услугите постоянно се създават и унищожават, е нужен механизъм за автоматично намиране на актуалните им адреси."
            },
            {
                "text": "Автоматичното откриване на нови технологии, които могат да се използват.",
                "isCorrect": false,
                "rationale": "Изборът на технологии е ръчен процес, а не автоматизирано откриване."
            },
            {
                "text": "Откриване на потребители, които използват системата.",
                "isCorrect": false,
                "rationale": "Това е свързано с анализи и мониторинг на потребителското поведение."
            }
        ]
    },
    {
        "questionNumber": 43,
        "question": "Кой от следните модели за справяне с грешки е често използван в разпределени системи като микросървисите?",
        "hint": "Помислете за електрически предпазител, който изключва веригата при проблем, за да предпази уредите.",
        "answerOptions": [
            {
                "text": "Fail-fast",
                "isCorrect": false,
                "rationale": "При този подход системата спира веднага при грешка, което не е желателно в разпределена среда, където се очаква устойчивост."
            },
            {
                "text": "Circuit Breaker (Предпазител)",
                "isCorrect": true,
                "rationale": "Този модел предотвратява многократни неуспешни извиквания към услуга, която е в неизправност. След определен брой грешки, 'предпазителят' се 'отваря' и заявките спират за известно време, давайки възможност на услугата да се възстанови."
            },
            {
                "text": "Try-Catch",
                "isCorrect": false,
                "rationale": "Try-Catch е езикова конструкция за обработка на изключения в рамките на един процес, а не модел за управление на грешки в разпределена система."
            },
            {
                "text": "Singleton",
                "isCorrect": false,
                "rationale": "Singleton е модел за дизайн, който гарантира съществуването на само една инстанция на даден клас, и не е свързан с обработката на грешки."
            }
        ]
    },
    {
        "questionNumber": 44,
        "question": "Какво е 'Dockerfile'?",
        "hint": "Това е 'рецептата' за създаване на вашия софтуерен пакет.",
        "answerOptions": [
            {
                "text": "Изпълним файл, който стартира контейнер.",
                "isCorrect": false,
                "rationale": "Това е командата `docker run`, а не Dockerfile."
            },
            {
                "text": "Текстов файл със скрипт от инструкции за автоматично изграждане на Docker image.",
                "isCorrect": true,
                "rationale": "Dockerfile съдържа команди като `FROM`, `COPY`, `RUN`, `CMD`, които описват стъпка по стъпка как да се сглоби имиджът."
            },
            {
                "text": "Конфигурационен файл за управление на мрежата на контейнерите.",
                "isCorrect": false,
                "rationale": "Мрежовата конфигурация се управлява с команди на Docker или чрез инструменти като Docker Compose."
            },
            {
                "text": "Централно хранилище за Docker images.",
                "isCorrect": false,
                "rationale": "Това се нарича 'registry' (напр. Docker Hub, AWS ECR)."
            }
        ]
    },
    {
        "questionNumber": 45,
        "question": "Кое от следните е най-доброто място за съхранение на парола за база данни, използвана от микроуслуга в контейнер?",
        "hint": "Къде бихте съхранили ключ за банков сейф - в джоба си или в друг, по-сигурен сейф?",
        "answerOptions": [
            {
                "text": "Директно в кода на приложението.",
                "isCorrect": false,
                "rationale": "Това е изключително лоша практика за сигурност, тъй като всеки с достъп до кода ще види паролата."
            },
            {
                "text": "В Dockerfile като променлива на средата (ENV).",
                "isCorrect": false,
                "rationale": "Променливите на средата в Dockerfile се 'запичат' в имиджа и могат да бъдат инспектирани, което не е сигурно."
            },
            {
                "text": "В специализирана система за управление на тайни (Secret Management System) и инжектирана по време на изпълнение.",
                "isCorrect": true,
                "rationale": "Това е най-сигурният подход. Услугата извлича тайната от защитено хранилище (като HashiCorp Vault или AWS Secrets Manager) при стартиране."
            },
            {
                "text": "В текстов файл до кода в Git хранилището.",
                "isCorrect": false,
                "rationale": "Това е също толкова несигурно, колкото и съхраняването на паролата директно в кода."
            }
        ]
    },
    {
        "questionNumber": 46,
        "question": "Какво представлява 'canary release' (канарчено внедряване)?",
        "hint": "Идеята идва от практиката на миньорите да носят канарче в мината, за да ги предупреди за наличието на опасни газове.",
        "answerOptions": [
            {
                "text": "Внедряване на новата версия на всички потребители едновременно.",
                "isCorrect": false,
                "rationale": "Това е стандартно внедряване, известно още като 'big bang'."
            },
            {
                "text": "Постепенно пускане на новата версия само за малка част от потребителите, преди да бъде пусната за всички.",
                "isCorrect": true,
                "rationale": "Това позволява да се тества новата версия в реална среда с ограничен риск. Ако се появят проблеми, те засягат само малък процент от потребителите."
            },
            {
                "text": "Внедряване на две версии едновременно, като потребителите могат да избират коя да използват.",
                "isCorrect": false,
                "rationale": "Това е по-скоро свързано със A/B тестване."
            },
            {
                "text": "Внедряване на нова версия, която е напълно изолирана от старата.",
                "isCorrect": false,
                "rationale": "Това описва 'blue-green deployment'."
            }
        ]
    },
    {
        "questionNumber": 47,
        "question": "Кой от следните инструменти НЕ е свързан с концепцията 'Infrastructure as Code'?",
        "hint": "Кой инструмент се използва за управление на работата на екипа, а не на техническите ресурси?",
        "answerOptions": [
            {
                "text": "Terraform",
                "isCorrect": false,
                "rationale": "Terraform е един от водещите инструменти за IaC, който позволява декларативно управление на инфраструктура в различни облачни доставчици."
            },
            {
                "text": "AWS CloudFormation",
                "isCorrect": false,
                "rationale": "Това е услугата на AWS за IaC, която позволява управление на AWS ресурси чрез JSON или YAML шаблони."
            },
            {
                "text": "Ansible",
                "isCorrect": false,
                "rationale": "Ansible се използва за управление на конфигурацията и автоматизация, което е тясно свързано с IaC, макар и с по-императивен подход."
            },
            {
                "text": "Jira",
                "isCorrect": true,
                "rationale": "Jira е инструмент за управление на проекти и проследяване на задачи, а не за управление на инфраструктура."
            }
        ]
    },
    {
        "questionNumber": 48,
        "question": "В кой слой на модела 'Defense in Depth' се намира Web Application Firewall (WAF)?",
        "hint": "Какъв тип трафик анализира WAF, за да открива заплахи?",
        "answerOptions": [
            {
                "text": "На ниво мрежа (Network Layer)",
                "isCorrect": false,
                "rationale": "На това ниво работят традиционните защитни стени (firewalls), които филтрират трафика по IP адреси и портове."
            },
            {
                "text": "На ниво приложение (Application Layer)",
                "isCorrect": true,
                "rationale": "WAF е специализиран да анализира HTTP трафика и да предпазва от атаки, насочени към уеб приложения, като SQL инжекции и Cross-Site Scripting (XSS)."
            },
            {
                "text": "На ниво данни (Data Layer)",
                "isCorrect": false,
                "rationale": "На това ниво защитата включва криптиране на данните и контрол на достъпа до базата данни."
            },
            {
                "text": "На ниво хост (Host Layer)",
                "isCorrect": false,
                "rationale": "Защитата на това ниво включва антивирусен софтуер, пач мениджмънт и контрол на достъпа до операционната система."
            }
        ]
    },
    {
        "questionNumber": 49,
        "question": "Каква е основната цел на хипервайзора (hypervisor) във виртуалните машини?",
        "hint": "Кой софтуерен слой се намира между физическия хардуер и операционните системи на виртуалните машини?",
        "answerOptions": [
            {
                "text": "Да управлява контейнерите.",
                "isCorrect": false,
                "rationale": "Контейнерите се управляват от container engine, а не от хипервайзор."
            },
            {
                "text": "Да създава, изпълнява и управлява виртуални машини, като абстрахира хардуера.",
                "isCorrect": true,
                "rationale": "Хипервайзорът (наричан още Virtual Machine Monitor) е софтуерът, който позволява на една физическа машина да изпълнява множество виртуални машини."
            },
            {
                "text": "Да осигури мрежова свързаност между VM.",
                "isCorrect": false,
                "rationale": "Това е една от функциите му, но основната му цел е абстракцията на хардуера и управлението на жизнения цикъл на VM."
            },
            {
                "text": "Да компилира кода на приложението.",
                "isCorrect": false,
                "rationale": "Компилацията на код не е свързана с функциите на хипервайзора."
            }
        ]
    },
    {
        "questionNumber": 50,
        "question": "Кое твърдение за връзката между микросървиси и контейнери е най-вярно?",
        "hint": "Помислете за контейнера като за идеалната 'кутия' за транспортиране на една микроуслуга.",
        "answerOptions": [
            {
                "text": "Микросървисите могат да съществуват само ако са в контейнери.",
                "isCorrect": false,
                "rationale": "Микросървисите могат да бъдат внедрени и на виртуални или физически машини, но контейнерите значително улесняват процеса."
            },
            {
                "text": "Контейнерите са технология, която е много подходяща за пакетиране и внедряване на микросървиси.",
                "isCorrect": true,
                "rationale": "Контейнерите предоставят изолация, консистентност и лекота, които са идеални за независимия жизнен цикъл на всяка микроуслуга. Те са перфектната 'опаковка' за микросървис."
            },
            {
                "text": "Всеки контейнер може да съдържа множество микросървиси.",
                "isCorrect": false,
                "rationale": "Добрата практика е един контейнер да съдържа само един процес/микросървис, за да се запази изолацията и независимостта."
            },
            {
                "text": "Контейнерите и микросървисите са две напълно несвързани концепции.",
                "isCorrect": false,
                "rationale": "Въпреки че са различни концепции (архитектура срещу технология за пакетиране), те са силно синергични и често се използват заедно."
            }
        ]
    }
];

        const questionTextEl = document.getElementById('question-text');
        const answerButtonsEl = document.getElementById('answer-buttons');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const progressTextEl = document.getElementById('progress-text');
        const scoreTextEl = document.getElementById('score-text');
        const questionAreaEl = document.getElementById('question-area');
        const resultsAreaEl = document.getElementById('results-area');
        const hintBtn = document.getElementById('hint-btn');
        const hintTextEl = document.getElementById('hint-text');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            questionAreaEl.classList.remove('hidden');
            resultsAreaEl.classList.add('hidden');
            nextBtn.classList.add('hidden');
            showQuestion();
        }

        function showQuestion() {
            resetState();
            const currentQuestion = quizData[currentQuestionIndex];
            questionTextEl.innerText = currentQuestion.question;
            hintTextEl.innerText = currentQuestion.hint;
            progressTextEl.innerText = `Въпрос ${currentQuestionIndex + 1} от ${quizData.length}`;
            
            currentQuestion.answerOptions.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer.text;
                button.classList.add('answer-btn', 'w-full', 'p-4', 'bg-gray-700', 'rounded-lg', 'text-left', 'hover:bg-gray-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'focus:ring-offset-gray-800', 'focus:ring-cyan-500');
                if (answer.isCorrect) {
                    button.dataset.correct = answer.isCorrect;
                }
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answerButtonsEl.appendChild(button);
            });
        }

        function resetState() {
            while (answerButtonsEl.firstChild) {
                answerButtonsEl.removeChild(answerButtonsEl.firstChild);
            }
            nextBtn.classList.add('hidden');
            hintTextEl.classList.add('hidden');
            hintBtn.classList.remove('hidden');
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';

            if (isCorrect) {
                score++;
            }

            Array.from(answerButtonsEl.children).forEach(button => {
                if (button.dataset.correct === 'true') {
                    button.classList.add('correct');
                } else {
                    button.classList.add('incorrect');
                }
                button.disabled = true;

                // Show rationale
                const rationaleEl = document.createElement('div');
                rationaleEl.classList.add('rationale', 'text-gray-300');
                rationaleEl.innerText = button.dataset.rationale;
                button.parentNode.insertBefore(rationaleEl, button.nextSibling);
            });

            if (quizData.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                showResults();
            }
        }
        
        function showResults() {
             questionAreaEl.classList.add('hidden');
             resultsAreaEl.classList.remove('hidden');
             nextBtn.classList.add('hidden');
             scoreTextEl.innerText = `${score} / ${quizData.length}`;
        }
        
        function showNextQuestion() {
            currentQuestionIndex++;
            showQuestion();
        }

        hintBtn.addEventListener('click', () => {
            hintTextEl.classList.remove('hidden');
            hintBtn.classList.add('hidden');
        });

        nextBtn.addEventListener('click', () => {
            if (currentQuestionIndex < quizData.length - 1) {
                showNextQuestion();
            }
        });
        
        restartBtn.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>