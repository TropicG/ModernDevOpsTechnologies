* Монолитна архитектура 

	Приложението е разработено като единна, неделима единица (single deployable unit), като целият код за всички функционалности се намира в една кодава база като се компилира и пакетира в един-единствен артефакт 
	Всички компоненти се изпълняват в рамките на един и същ процес в паметта на сървъра и се споделят общи ресурси като CPU, RAM 
	
	Технически характеристики:
	- Силна свързаност: Модулите са силни зависими един от друг, директното извикване на методи и функции между модулите е практика 
	- Единна технология: Цялото приложение може да бъде написано на един програмен език 
	- Централизирана база данни: Всички данни за разчлините функционалности се съхраняват в една база 
	- Внедряване: Дори и най-малката промяна налага повторно компилиране, тестване и внедряване на приложението 
	
* Микросървисна архитектура 

	В тази архитектура приложението е декомпозирано на колекция от малки, независми и автономни услуги, като всяка услуга реазлизира конкретна бизнес функционалност 
	Всяка микроуслуга се изпълнява в собствен, отделен процес и може да бъде внедрена на отделен съвър или контейнер (за пример Docker)
	
	Технически характеристики:
	- Слаба свързаност: Понеже услугите се независими, комуникацията между тях се случва през мрежата чрез API-та 
	- Независимост на даните: Всяка услуга притежава собствена база данни
	- Полиглотна архитектура: Всяка услуга може да бъде разработена с различна технология, която е най-подходяща за нейната цел 
	- Независимо внедряване: Промени в една услуга изисква повторно внедряване само и единствнео на тази услуга, без да се засягат останалите 
	- Устойчивост: Срив в една услуга не води до срив на цялото приложение, останалите услуги могат да продължат да си функционират 
	- Паралелна разработка: Различни екипи могат да разработват, тестват и внедряват своите услуги независимо и едновременно 
	- Ефективно мащабиране: добавят се само ресурси само за конкретната услуга, която е натоварена 
	
	Всяка микроуслуга отговаря на принципа за единствената отговорност (Single Responsobility Principlе), защото има ясни и дефинирани цели и не се занимава с функционалности извън нейния домейн 
	
* От какво се съдържа един микросъврис 

	Вътрешната структура на един микросървис се състои от три основни компонента:
	- Application/Logic: Това е изпълнимия код на услугата, тук се съдържа бизнес логиката зад една конкретна функционалност
	- Data store: Всяка микроструктура притежава и управлява собствена, изолирана база данни, като никоя друга услуга няма достъп до това хранилище
	- Public API: Това е единственият входен пункт към услугата, API-a дефинира как други услуги могат да комуникират с него
	
* 6те принципа на микросървисите 
	
	Ето какво представляват принципите:
	- 1# Rely only on the public API: услугите трябва да комуникират помежду си единствено през техните API-та, дирекният достъп до базата данни на друга услуга е строго забранено
	- 2# Use the right tool for the job: Понеже услугите са независими, всяка от тях може да бъде изградена с различна технология. Може една услуга да е на Python, а друга на Go. Идеята е да се избират правилните инструменти 
	- 3# Secure your services: Всяка услига трябва да си имплементира собствен механизъм за сигурност като автентикация и авторизация и да се валидират всички входящи заявки 
	- 4# Be a good citizen within the ecosystem: Услугата трябва да е проектирана така, че да е устойчива и да е наблюдаема 
	- 5# It's more than just technology transformation
	- 6# Automate everything: Автоматизацията е ключова
	CI/CD: автоматизира тестването и внедряването 
	IaC: Автоматизирано създаване и управление на инфраструктурата
	Monitoring & alert: Автоматизирано наблюдаване и известяване при проблеми 
	
* Rely only on the public API

	Този принцип определя как услугите трябва да комуникрат помежду си.
	
	Правилния начин за комуникране между две услуги е комуникацията между техните публични API-та, API-то показва какво операции са възможни между услугите
	Грешен начин е ако една услуга заобикаля API-то на другата услуга и директно пипа нейните данни
	
	Това правило реално извършва енкапсулация, защото скрива вътрешните данни на двете услуги.
	Дори в бъдеще ако едната услуга промени вътрешните си данни това няма да афектира другата услуга с която комуника, това се нарича и слаба свързаност 
	
	Понеже API-A е единствения входен пункт на услугата, всяка промяна в него може да счупи другите услуги, които разчитат на него. Затова е важно да се има стратегия за версиониране.
	Именно често срещан подход е Семантичното версиониране (Semantic Versioning), което е буквално наименуване на версии като 1.1 или 1.5
	
* Use the right tool for the job

	Това означава, че не сме обвързани само с една технология за цялата система. Микросървисната архитектура позволява разбообразие в избира на технологиите
	
	Има две основни концепции:
	- Polyglot frameworks: Различните услуги могат да бъдат написани на различни езици за програмиране и фреймуърци, една услуга може да е написана на Node.js, друга на Java 
	- Polyglot persistence: Всяка услуга може да използва най-подходящия тип бази данни за своите нужди
	Може да се използва Amazon DynamoDB (подходяща за бърз достъп до данни по ключ) или Amazon Elasticsearch Service (оптимизирана за сложно търсене в текст), че може и заедно да се ползват 
	
* Secure your services

	В микросървисната архитектура сигурността трябва да се прилага на множество нива, понеже всяка услуга може да се атакува 
	
	Има пет ключови практики за сигурност:
	- Defense in Depth: Стратегия, в която се прилагат множество независими слоя на сигурност, дори и един да бъде пробит, другите ще продължат да защитават системата 
	- Gateway: Използва се API Gateway като единствен централизиран пункт за достъп, всички заявки минават през него и това позволява централизирано място за прилагане на сигурност 
	- API throttling: API Gateway-ът може да ограничи броя на заявките, които един клиент може да направи за определен период от време (rate limiting), това предпазва услугите от DDoS атаки 
	- Secret Management: Услугите се нуждаят от чувствителна информация като пароли за бази данни, API ключове и други неща, тези тайни не се съхраняват в кода. Има специализирани системи (като AWS Secrets Managere) за тяхното съхранение и достъп по време на изпълнение 
	
	Относно автентикацията и оторизацията, ова са два отделни процеса, които се управляват от API Gateway-а:
	- Автентикация: Проверява се клиента кой е, ова може да става чрез парола или име или JWT токен 
	- Оторизация: След успешна автентикация се проверява какви права има потребителя 
	
* Be a good citizen within the ecosystem

	Този принцип означава, че една микроуслуга не работи в изолация, тя трябва да бъде проектирана, за да е:
	- предвидима: другите услуги да знаят как да работят с нея 
	- надеждна: услугата работи постоянно и е устойчива на грешки, дори да възникне проблем, тя да знае как да се справи с него 
	- прозрачна: лесно да се разбере какво се случва вътре в нея, да се предоставят достатъчно логове и метрики, които показват нейното състояние 
	
	Има три основни аспекта, които трябва да се постигнат:
	- SLA (Service Level Agreement) дефинира възможностите и гаранциите, които една услуга предоставя, това включва:
		1. Очакваното натоварване (Expected load), колко трансакции в секунда (TPC) може да поеме услугата 
		2. Очаквана латентност (Accepted latency), колко бързо се очаква услугата да отговори 
		3. Достъпност (Availability), какъв процент от времето се гарантира, че услугата ще бъде достъпна 
	Реално да бъдеш добър гражданин означава услугата да публикува и спазва своите SLAs 
	
	- Контролиран достъп и регистрация на клиенти: Една услуга не може да позволи анонимен или неконролиран достъп, затова:
		1. Изисква се конкектс от услугата, която иска да е ползва, като пита защо и как 
		2. Предоставяе се разрешение едва след като услугата е наясно с целта и предоставя разрешение 
		3. Регистрира клиента, който ползва тази услуга 
		
	- Наблядаемост: една услуга трябва да бъде проектирана така, че да може да се проследи и това се постига чрез:
		1. Споделени метрики, самата услуга излъчва метрики като време за отговор на заявка, брой грешки 
		2. Разпределено проследяване, всяка заявка получава уникално ID, който се предава през всички услуги, участващи в обработката й
		3. Метрики за потребителското изживяване: събиране на данни, които показва как производителността на услугата влияе на крайния потребител 
		
* It's more than just technology transformation
	
	Принципа гласи, че за да бъдет успешни микросъврисите се изисква промяна в структурата на екипите, която да отразява архитектурата на софтуера
	
	Идеалната организационна структура представлява:
	- Организация от малки, фокусирани екипи, екип от 5-8 души подобрява комуникацията и скоростта на вземане на решения 
	- Всеки малък екип има собствен, незабисим pipeline за доставка на софтуер, това позволява на екипите да пускат нови версии на своите услуги 
	- Всеки екип поема пълна отговорност и собственост върху една или няколко конкретни микроуслуги 
	
* Automate everything
	
	Автоматизацията е задължителна при работа с микросървиси, понеже ръчното управление на десетки услуги е невъзможно 
	
	Три примера за AWS услугите, които показват ключовите етапи на автоматизацията в един CI/CD процес:
	- AWS CodeCommit е Git-базирано хранилище за код, автоматизацията започва тук, като всяка промяна в кода автоматично задейства следващите стъпки 
	- AWS CodePipeline e услуга която дефинира и автоматизира целия път на кода от хранилището до продукция, съдържа етапи като автоматично компилиране, изпълнениет на тестовете и изчакване на одобрение преди внедрпяване 
	- AWS CodeDeploy (Автоматично внедряване) е услуга, която автоматично внедрява новата версия в различни среди 
	
* Какво представлява container-a 

	Контейнерът е стандартизиран, изпълним пакет, който съдържа всичко необходимо за стартирането на едно приложение, този пакет капсулира:
	- Приложението, това е кода, който изпълнява бизнес логиката 
	- Зависимости (Dependencies), това са всички библиотеки, frameworks и други софтуерни компоненти, от които кодът се нуждае, за да работи 
	- Конфигурации, това са всички конфигурационни файлове и настройки, необходими за правилното функциониране на приложенито в дадена среда 
	- Интерфейс към ОС (Hooks into OS), това е начина, по който приложението взаимодейства с ядрото на операционната система. Контейнера осигурява изолирана среда,
	но споделя ядрото на хост машината, което го прави много по-лек от виртуалната машина 
	
	Общо взето контейнерът изолира приложението и неговата среда, гарантирайки, че то ще работи независимо къде е стартирано

* Какво проблеми разрешава контейнера?

	Контейнера гарантира, че софтуера ще работи по един и същ начин в различни среди 
	
	Понеже самият софтуер ще се тества на компютъра на разработчика, на компютър в някаква тестова среда или вече като е в продукционна среда много е вероятно
	тези различни среда да имат различни версии на ОС или да имат различни инсталирани библиотеки
	
	Именно контейнерът разрешава този проблем, като пакетира приложението заедно с цялата му среда, тоест неговите зависимости, библиотеки и конфигурационни файлове.
	Този пакет е непроменяем и преносим
	
	Когато едно приложение е "контейнеризирано" то се стартира и работи по абсолютно идентичен начин, независимо на каква машина се намира 
	
* Предимства на контейнерите 

	Контейнерите имат 3 хубави предимства:
	- Контейнерът гарантира, че приложението се стартира и работи по идентичен начин всеки път, независимо от средата.
	Понеже целият пакет е непременяем се елеминират грешки, причинени от разлики в средити.
	
	- Контейнерът е самостоятелна среда за изпълнение, защото е напълно капсулиран и изолиран. Той съдържа абсолютно всичко, от което приложението се нуждае,
	и не зависи от софтуера, инсталира на хост машината. Това позволява много контейнери да работят на един и същи сървър, без да си влият един на друг 
	
	- По-бързо стартиране и спиране от виртуалните машини, защото контейнера споделя ядрото на ОС на хост машината и виртуализират само потребителското пространство.
	За разлика от тях, VMs емулират цялата операционна система включително и ядорото, но контейнерите имат лека архитектура и това им позволява да се стартират и спират до милисекунди или секунди 
	
* Разликите между VM и контейнер 

	Виртуалните машини абстрахират хардуера, докато контейнерите абстрахират операционната система 
	
	Виртуалните машини:
	- Всяка VM работи върху хипервайзор, който емулира цял физически компютър и върху този хардуер се инсталира пълна, отделна операционна система 
	- Осигурява силна изолация понеже всеки VM е напълно независим и има собствено ядро 
	- Много са тежки и консумират много ресурси и стартират доста бавно, бая минути 
	
	Контейнерите:
	- Всички контейнери работят върху една и съща операцонна система на хоста и споделят нейното ядро, Conteiner engine като Docker, управлява изолацията между тях 
	- Изолацията е на ниво процеси, контейнерът пакетира само приложението и неговите библиотеки, без да включва гост операционната система 
	- Изключително леки и стартират мигновенно и използват ресурсите по-ефективно 
	

	