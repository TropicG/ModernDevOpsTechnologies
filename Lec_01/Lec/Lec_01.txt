* Waterfall модела 

	Waterfall Model е класически пример за жизнения цикъл за разработка на софутер (Software Development Life Cycle - SDLC)
	
	Обяснение на фазите, през които се минава:
	- Requirement Analysis: В тази фаза се събират, анализира и документират всички функционални и нефункционални изисквания към системата 
	
	- System Design: На базата на изсикванията се създава софтуерна архитектура на системата. Тук се дефинират хардуерни и софтуерни компоненти, структури на данните, модули, интефейси и алгоритми
	Има два типа дизайн, High-Level Design (HLD) тук е архитектурата и основните модули, а в Low-Level-Design (LLD) се описват детайлите на всеки модул
	
	- Implementation: Разработчиците пишат код базирано на избраната софтуерна архитектура и спецификацията 
	- Testing: След като кода е завършен се прави проверка на софтуера от QA екипа, те проверяват за дефекти и дали системата отговоаря на първоначалните изисквания 
	- Deployment:  След като бъде успешно тестван, софтуера се инсталира в продукционна среда, за да бъде доставен до крайните потребители 
	- Maintenance: След deployment-а се извършват корекции на открити в реална среда бъгове, правят се подобрения по функционалности и се адаптира системата към новите изисквания 
	
	Ключовата характеристики на този медол е неговата стриктна последователност, защото връщането към предишната фаза за нанасяне на корекции е трудно и скъпо
	
* Lean Startup 

	Цикъла Build-Measure-Learn е основна концепция в методологията Lean Startup 
	Този процес е създаде н за бързо и ефективно разработване на продукти и бизнеси чрез непрекъснато валидиране на идеи, целта е да се минимизира общото време за преминаване през цикъла 

	Обяснение на цикъла:
	- Ideas: всичко започва с идея или хипотеза, за пример може да се предприеме, че потребителя ще плати за дадена функционалност, който решава проблем 
	- Build/Code: Вместо да се изгради цялостен продукт се изгражда Minimal Viable Product (MVP), това е най-простата версия на продукта, която е достатъчна, за да тества основните идеи
	- Measure: МVP-то се пуска на пазара и целта е да се съберат реални, количествени данни за поведението на потребителите. Тук се използват actionable metrics (тоест, метрики, които водят до конкретни резултати)
	- Data: Oт measure фазата се събират данните, както количествени данни, така и качествени 
	- Learn: Анализират се събраните данни, за да се валидира или отхвърли хипотезата/идея от Ideas фазата.
	
	Базирано на събраните резултати в Learn, се взима едно от двете решения:
	- Persevere: Ако хипотезата е валидирана, идеята се доразвива.
	- Pivot: Ако хипотезата е отхвърлена, се прави фундаментална промяна в стратегията, без да се започва от нулата.
	
* Методологията DevOps 

	DevOps е съвременна методология за разработка на софтуер, която обединява разработката (Dev) и операциите (Ops)
	Това е непрекъснат, итеративен и автоматизиран процес, които има за цел да скъси жизнения цикъл на разработка на софтуер и да се осигури непрекъсната доставка (Continuous Delivery) с високо качество. 
	
	Фазите на Dev часта:
	- Plan: дефинират се бизнес изискванията и се планират задачите 
	- Code: Тук е фазата с пишене на код, управлението на сорс кода се извършва чрез системи като Git 
	- Build: Сървъри за CI (Continious Integration) като Jenkins или Gitlab автоматично изтеглят новия код, компилират го и създават изпълними артефакти (дали Docker Image или нещо друго)
	- Test: В рамките на CI/CD pipeline-a се изпълняват автоматизирани тестове, за да се гарантира, че новия код не чупи нищо 
	
	Фазите на Ops частта:
	- Release: След успешно преминаване на тестовете, артефактът се версионира и се подготвя за пускане в продукционна среда.
	- Deploy: Процесът на инсталиране на артефакта в продукционна среда е автоматизиран (Continuous Deployment/Delivery - CD) и се използват технологии като Infrastructure as Code (IaC) с инструменти като Kubernetes
	- Operate: Приложението работи в реална среда, обслужвайки крайните потребители, като тук се управляват конфигурации, мащабиране и поддръжка на софтуера 
	- Monitor: Производителността на приложението, използването на ресурси и евентуални грешки се следят непрекъснато, събраните данни и обратна връзка се връщат обратно във фазата на планиране 
	
	Ключовото именно в DevOps е автоматизацията и културата на сътрудничество между екипите, което позволява по-бързо, по-често и по-надеждно доставяне на софтуер 

* Главната идея зад DevOps 

	Основната идея на DevOps е да се премахне разделенито между Dev и Ops екипите, като се интегрират екипите, процесите и инструментите.
	Чрез премахването на разделението между екипите, организацията може да:
	- Съкрати времето за доставка (Shorten Lead Time) като процесът става по-гладък и оптимизиран, което позволява по-бързо внедряване на нови функционалности 
	- Подобри обратната връзка (Improve Feedback) като се установи директен, непрекъснат цикъл на обратна връзка.
	
* С какво DevOps помага относно Agile Manifestoto 

	DevOps практиките директно подпомагат постигането на Agile целите:
	- "Our highest priority is to satisfy the customer through early and continuous delivery of valuable software"
	DevOps решението тук е Continuous Integration (CI) и Continuous Development (CD), чрез автоматизирани pipelines, DevOps позволява всяка промяна в кода да бъде тествана и готова за пускане, което прави "непрекъсната доставка" възможнос
	
	- "Delivering working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale"
	DevOps автоматизира компилирането (build), тестване и внедряването (deployment), кеото намалява времето и усилията, които са нужни за пускане на нова версия 
	
	- "Continuous attention to technical excellence and good design enhances agility"
	Infrastructure as Code (IaC) автоматизира тестове за сигурност (DevSecOps) и статичен анализ на кода. Тези практики се вграждат в CI/CD pipeline-a 
	
* Автоматизирания CI/CD pipeline на Amazon Web Service 

	През какви етапи се минава в AWS CodePipeline-a:
	- Author (Създаване): Когато се пише код се използва AWS Cloud9 (това е облачно-базирано IDE) и AWS IDE Toolkits (плъгъни за локалното IDE, които улесняват работата с AWS)
	- Source (Източник): Кодът се съхранява в AWS CodeCommit, което е управляемо Git хранилище, подобно на GitHub/GitLab
	- Build (Компилиране): AWS CodeBuild е услуга, която компилира сорс кода, изпълнява тестове и създава софтуерен артефакт (примерно DockerImage)
	- Test (Тестване): Направения артефакт се тества за качество, може да се използва AWS CodeBuild, заедно с third party инструменти, за да се направи главни тестове.
	- Deploy (Внедряване): AWS CodeDeploy е услугата, която автоматизира внедряването към различните среди 
	- Monitor (Наблюдение): Amazon CloudWatch е услуга, която събира логове и метрики, за да се наблядава приложението за проблеми и производителност
	
	AWS Cloud Development Kit и AWS SAM са инструменти за Infrastructure as Code (IaC), които позволяват да се дефинират цялата AWS инфраструктура (сървъри, бази данни и самият pipeline) като код.

* GitLab CI/CD pipeline 

	Този процес има две основни части: CI Pipeline и CD Pipeline 
	
	CI Pipeline
	Целта и е бързо да се провери дали новият код е качествен и се интегрира добре 
	Сорс кода тук може да се компилира и да се създаде изпълним артефакт 
	Изпълняват се автоматизирани тестове, за да се открият бъгове възможно най-рано като Unit тестове и Integration тестове 
	ко някоя от тези стъпки се провали, pipeline-ът спира и се получава обратна връзка, за да се оправи проблема 
	
	CD Pipeline (този процес започва, когато CI pipeline-a е бил успешен)
	Промените се качват на временна, динамична среда, където QA инжинерите или други могат ръчно да прегледат и да тестват новата функционалност 
	След одобрение на промените, кода се внедрява в "stading" среда. Тя е максимално близка до продукционната и служи за финални тестове
	След като всички проверки в stadging средата са успешни, кодът се внедрява в live среда, където става достъпен за крайните потребители 
	
	Общо взето GitLab CI/CD автоматизира целия процес, като прави доставката на софтуер по-бърза, по-надеждна и с по-малък риск от човешки грешки 
	
*  Основните разлики между DevOps концепции 

	Има три ключови DevOps концепции: Continuous Integration, Continuous Delivery и Continuous Deployment.
	
	Фазите през, които се минава за Continuous Integration:
	- Всеки път, когато някой направи commit се задейства автоматизиран процес, който изтегля промените, компилира ги и прави основни тестове 
	Тази фаза гарантира, че новия код се интегрира правилно и не чупи нищо 
	
	Фазите през, които се минава за Continuous Delivery:
	- Всички стъпки от CI да се изпълнят 
	- При успешни стъпки, кодо автоматично влиза в staging среда 
	- В тази staging среда се изпълняват по-сложни тестове (интеграционни, тестове за натоварване)
	- Софтуерът е готов за пускане в експлоатация с едно натискане на бутон, обаче финалното внедряване в продуктовия код иска удобрение 
	
	Фазите през, които се минава за Continuous Deployment:
	- Всички стъпки от Continuous Delivery са изпълнени 
	- Обаче, ако всички тестове в staging средата са успешни, самото внедряване се случва автоматично, без човешка намеса 
	
* Source Code Managment 

	SCM е съкращението за Source Code Management, познато още и като Version Control 
	
	Някой от основните свойства на тази система:
	- проследява текущата история на промените в кода: Всяка промяна в кода се запазва като commit, а той съдържа всички промени, информация за автора, дата и уникален индентификатор .
	Това създава пълна, хронологична история на всеки ред и показва кога и от кой е имало промяна. Това позволява и лесно да се връща на минала версия 
	
	- помага за разрешаването на конфликти, а един конфликт възниква, когато двама променят едни и същи редове код в един и същ файл по едно и също време.
	SCM засича този конфликт и позволява да се избере по кой от двата начина да се реши и да се продължи 
	
	- много разработчици работят в споделена кодова база чрез branching. Така всеки може да създаде свое собствено копие на основния код 
	
* Basic Git Flow 

	Това е най-опростения работен процес в Git, който се нарича централизиран работен процес (Centralized Workflow)
	
	В този процес имаме един основен бранч, наречен master и това представлява една права верига от комити.
	Общо взето в този процес всички разработчици правят промените директно върху този единствен клон 
	
	Този модел е изключително рисков за екипова работа, защото ако някой качин нестабилен код, това ще засегне целия екип.
	Този модел никога не се използва в професионалната практика, освен за малки проекти
	
* Git Feature Branch Workflow 

	Това е най-стандартната практика за разработка в екип, защото осигурява изолация и безопастност 
	
	Имаме един бранч, който е master, който съдържа винаги стабилен, работещ код и може да бъде пуснат да работи по всяко време.
	От някой комит на master бранча, имаме разклонение в branch feature, в този бранч тестваме нова функционалност или оправяме бъг.
	Промените във feature branch-a няма да засегнат master branch-a освен, ако не се merge-не
	Когато е имплементирана функционалността във feature бранча се прави MergeRequest, за да може да се слее този код в master branch-a, след проверка с екипа 
	
* Git feature Workflow with stable branches 

	Тук в този работен процес се въвежда допълнително ниво на стабилност чрез клона develop 
	
	Тук има няколко бранча:
	- master бранча е само за продукция, който съдържа само изключително стабилен код, като всеки комит на него представлява нова официална версия 
	- develop бранча е интеграционния клон, той съдържа всички завършени и одобрени функционалности, който са готови за следващата версия 
	- работните клонове (feature) са временни клонове, който се бранчват от develop и върху тях се разработва и тества нова функционалност 
	
	Основните предимства на този процес:
	- Супер стабилен е защото master брача никога не е подложен на нестабилен код от разработка, той се актуализира само когато е време за официална версия 
	- Процеса е много по-организиран, защото се знае винаго какво е в продукция (master) и какво ще бъде в следващата версия (develop) и какво се разработва сега (feature) 
	
* Git flow 

	Git flow е един от най-известени, стриктни и пълни работни процеси за управление на Git проектите, той е идеален за проекти с планирани цикли на издаване 
	
	Основните бранчове:
	- master бранча съдържа само продукционния, стабилен код като всеки commit там е нова официална версия и трябва да бъде маркиран с етикет tag и номер на версията 
	- develop е основният интеграционен клон за разработка. Той съдържа най-новия код с всички завършени функционалности, които могат да бъдат включени в следващия release 
	
	Supporting бранчове:
	- feature бранчовете са тези за разработка на нови функционалности, те произлизат от develop и се сливат обратно в develop 
	- release бранчовоте са подготовката за ново издание, в този бранч се прави само финални поправки на бъгове и не се добавя нова функционалност, излиза от develop и се слива с master 
	- hotfix бранчовете са само за спешни поправки на бъгове в продукционната среда, те произлизат директно от master, когато има критичен проблем, който не може да чака следващия release  