* Монолитна архитектура

	Монолит в софтуера е приложение, което е изградено акто едно-единствено неделимо цяло.
	
	Основни характеристики:
	- Има единна кодова база като всички функции на приложението се намират в един и същ голям проект 
	- Има силна обвързаност защото всички компоненти са плътно свързани, ако променим една малка част, може да се наложи да тестваме и внедряваме цялото приложение 
	- Единно внедряване като цялото приложение се стартира като един-единствен процес или услуга на сървъра
	
	Традиционен подход, който е лесен за стартиране, но може да стане труден за поддръжка и мащабиране, когато приложението стане прекалено голямо 
	
* Микросървисна архитектура 

	Миркосървисната архитектура е подход, при който едно голямо приложение се изгражда като набор от малки, независими услуги, като всяка една услуга отговаря за една-единствена бизнес функция 
	
	Основните характеристики:
	- Независимост, защото всяка услуга е отделно мини-приложение, като си има своя собствена кодова база и често собствена база данни 
	- Слава обвързаност, защото промяна в една услуга не изсиква промяна, тест или рестарт на другите услуги 
	- Има отделно внедряване защото можем да пуснем нова версия само на една услуга по всяка време, без да се засяга цялата система 
	- Различните услуги комунират помоежду си през мрежата (за пример чрез APIs)  вместо да са в един и същи процес 
	
	Този подход е по-сложен за първоначална настройка, но прави големите приложея много по-лесни за поддръжка, промяна и мащабиране 
	
* Как Kubernetes управлява различните услуги в микросървисна система 

	Kubernetes е софтуерна система, която автоматизира инсталирането, стартиране и управлението на микросървисите (които работят в контейнери)
	Главния принцип е че се декларира желаното състояние в конфигурационните файлове, а Kubernetes активно работи за да постигне и поддръжа това състояние 
	
	Главните задачи, които прави Kubernetes:
	- Разполагане (Deployment), ако се нуждаем от 3 копия на даден софтуер или услуга, Kubernetes само намира къде има свободни ресурси и стартира тези копия
	- Мащабиране (Scalling), ако даден трафик на приложението се увеличи и искаме да го мащабиране, kubernetes автоматично стартира новите копия
	- Поддържане на състоянието (Self-healing), Kubernetes постояно следи дали различни контейнери работят, като той засича, ако някой спре да работи. 
	- Мрежова комуникация (Service Discovery), Kubernetes управлява връзката на различните контейнери в мрежата 
	
* Какво представляваха контейнерите

	Контейнерът е пакет, който съдържа абсолютно всичко, от което приложението се нуждае, за да работи, тоест самият код, библиотеки и други зависимости 
	Контейнерите са възможни благодарение на две linux функционалности:
	- Namespaces (Изолация), това е функция, която кара приложението да си мисли, че е само на компютъра, като му дава собствена изолирана среда 
	- Cgroups (Лимит), това ограничава колко CPU и памет може да използва този контейнер 

	Контейнерите са много по-лека версия на виртуалните машини:
	- Виртуалните машини симулират цял компютър и има собствена пълна операционна система, това обаче е тежко и хаби много ресурси 
	- Всички контейнери споделят операционната система на сървъа, те опаковат само приложението и неговите зависимости 
	
	Главно предимствата на контейнерите са:
	- LightWeight, защото стартират за секундим защото не зареждат цялата  OC
	- Portable, защото работят еднакво навсякъде където има инсталиран Docker 
	- Isolated, защото процесите в един контейнер не си пречат с тези в други, въпреки че са на една и съща ОС 
	
	Основните компоненти на един контейнер:
	- Container е самото работещо приложение 
	- Container Images e самият пакет, който съдържа всичко 
	- Container Runtime (Среда за изпълнение), това е самият двигател, който реално стартира и управлява контейнерите като Docker 
	- Container Registires е складът като Docker Hub, където се съхраняват всички имиджи 
	
* Каква е архитектурата на Kubernetes
	
	Kubernetes има клиент-сървер архитектура 
	
	Control panel-a на Kubernetes е като мозъка на цялата система, има рзлични компоненти, които си взаимодействат по различни начини:
	- API Server-a е главния вход на контролния панел, през него минават командите, който са зададени от kubectl или web interface-a 
	- Etcd е самата памет на контролния панел, защото сук се съхранява цялата конфигурация и желаното състояние на клъстъра 
	- Scheduler има работа да решава на кой Node да пуска нов контейнер, когато се появи заявка за това 
	- Controllers са работниците, които постоянно набдлюдават състоянието, те имат задачата да гарантират, че реалното състояние на клъстъра отговаря на желаното състояние, записано в Etcd 
	
	В този контекст клъстър означава група от компютри (сървъри), които работят заедно и се управляват като една-единствена система 
	
	Node е сървърът-работник, който реално изпълнява приложенията, за да бъде обаче част от клъстъра всеки Node трябва да има следните компоненти:
	- Kubelet е основният агент, който комуникира с control panel-a и изпълнява неговите команди 
	- Kube-proxy отговаря за всички мрежови правила на този сървър, за да позволи контейнерите да комуникират помежду си и с външен свят
	- Container Runtime е двигателят (като Docker), който рреално стартира и управлява самите контейнери 
	- cAdvisor събира метрики и информация за това как работят контейнерите и колко ресурси използват 
	
* Namespaces 

	Namespaces е механизум за логическо разделение и изолиране на ресурси в рамките на един-единствен Kubernetes клъстър, с други думи позволява разделените клъстера на няколко "виртуални клъстъра"
	
	Основните функции на един namespace са:
	- Организация (Scope), тоест позволява да се групират свързани ресурси 
	- Контрол на достъпа е основният начин да се дефинират правата на потребителите, може един екип да има пълни права само в техния namespace 
	- Ограничаване на ресурсите (Resource Quota), тоест може да се задават лимит за общото количество CPU и памет, което може да се използва от приложенията в даден namespace 
	
* Pod 

	Pod е най-освновната работна единица в Kubernetes 
	
	Понеже не се стартират контейнерите директно, те се стартиран вътре в Pod, това е най-малкото нещо, което Kubernetes създава и управлява
	Възможно е един Pod да съдържа един или повече от един контейнери, ако примерно те са много тясно свързани и трябва да работят заедно 
	
	Важно е да се знае, че всички контейнери вътре в един и същу Pod се държат все едно са на една и съща машина:
	- те споделят мрежата като могат да си комуниракат помежду си чрез localhost 
	- те споделят дисковото пространство 
	- винаги работят заедно на един и същи Node (сървър)
	
* Създаване на един Pod 

	Използваме yaml конфигурационни файлове, за да опишем Pod, който искаме да създадем
	
	Виж PodExample.yaml 
	
	Някой от ключовите думи, които може да се намерят във файла:
	- kind: Pod (Казваме на Kubernetes, че искаме да създадем Pod)
	- name: flask-pod (Pod-ът ще се казва flask-pod)
	- image: digitalocean/flask-helloworld:latest (вътре в Pod-a ще има един контейнер, който ще подкара този image)
	- containerPort: 5000 (Задаваме приложението да работи на порт 5000)
	
	Някой kubectl команди, които управляват даден Pod:
	- kubectl apply -f PodExample.yaml -n flash (стартира Pod-a в клъстъра, използвайки yaml файла)
	- kubectl get pod -n flash (проверяваме статуса на Pod-a, които туко що създадохме)
	- kubectl port-forward -n flask pods/flask-pod 5000:5000 (свързва порта 5000 на компютъра с порта 5000 на Pod-a, за да можем да го достъим )
	
* Workloads

	Workloads в Kubernetes са различни начини за стартиране на приложения 
	
	Има няколко различни начина за стартиране на приложение:
	- Deployments (за stateless приложения) е най-често срещания начин, използвайки се за приложения без състояние, като web servers или api, където всяко копие на приложението е взаимнозаменямемо
	- StatefulSets се използва за приложения, които имат състояние и се нуждаят от стабилна, уникална идентичност и постоянаа памет, за пример може да се говори за бази от данни 
	- DaemonSets гарантира, че по едно копие на опреедлен Pоd ще работи на всеки Nod
	
* Deployment 

	Deployement е обект, който помага с управлението на Pod-овете, които съдържат приложениея
	
	Deployement позволява вместо ние ръчно да управляваме Pod-a, Deployement го управлява базирано на дадени изисквания
	Понеже не се създават Pod-ове директно, Deployement получава инфромация че някакви копия трябва да се получат от даден Pod и той се погрижва
	
	
	Трите основни функционалности на един Deployement:
	- Deployment описва желаното състояние (примерно 3 копия на версия 1.0 на дадено приложение)
	- Scaling позволява лесно да се промени броя на Pod-овете 
	- Updates позволява да се обнови приложението до по нова версия 
	

	