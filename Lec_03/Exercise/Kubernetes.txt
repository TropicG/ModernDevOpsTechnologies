* Create a namespace called 'mynamespace' and a pod with image nginx called nginx on this namespace 

    This is two-part task:
    - create a logical grouping arae (a namespace) called mynamespace
    - create a single running container (a pod) named nginx, using nginx software image and place it inside mynamespace namespace

    kubectl create namespace mynamespace
    (create namepace): This tells Kubernetes to create a new names. Namespaces are a way to divide cluster resources between multiple users or teams
    (mynamespace): is the name given to that namespace

    kubectl run nginx --image=nginx --restart=Never -n mynamespace
    (kubectl run nginx): This is the action to create a new resource, nginx is the name given to this new resource (in this case, the pod)
    (--image=nginx): This flag specifies which container image to use, it pulls the official nginx web server image (prob from DockerHub)
    (--restart=Never): by default kubectl might create a Deployment (which manages pods), settings this flag tells Kubernetes to create a single, standalone Pod object
    (-n mynamespace): it tells kubectl where to create the pod, without this it would have created it into the default namespace 

* Create the pod that was just described using YAML 

    This method first generates a "blueprint" (the YAML file) and then tells Kubernetes to build that what is in that blueprint 

    kubectl run nginx --image=nginx --restart=Never --dry-run=client -n mynamespace -o yaml > pod.yaml
    - NOTE: THIS COMAND GENERATES THE YAML FILE AND IT DOES NOT CREATE THE POD
    (--dry-run=client): it tells kubectl "Dont actually create anything in the cluster, just figure out the configuration you would use"
    (-o yaml): this flag means --output=yaml it tells kubectl to print the configuration it generated in YAML format 
    (> pod.yaml): this is basic shell redirect, it takes the YAML output (which would go to the screen) and saves it into a file named pod.yaml

    Check pod.yaml to see what is inside:
    (kind: Pod): specified the type of Kubernetes object
    (metadata: ): contains data about the object like name and in which namespace it will be created
    (spec: ): hold the specification for the pod like its containers what images will they have

    kubectl create -f pod.yaml
    (-f pod.yaml): The -f flag tells kubectl to read the resource definition of the yaml file

* Create a busybox pod (using kubectl command) that runs the command "env". Run it and see the output

    The objective is to create a pod using the busybox image, its job is to execute a single command env (which lists all environment vairables) and show the result

    Method I: Interactive and Auto-Remove
    kubectl run busybox --image=busybox --command --restart=Never -it --rm -- env
    (kubectl run busybox --image=busybox): creates a pod named busybox using the busybox image
    (--command): this flag tells Kubernetes not to run the image's default command. but to run the command that follows
    (--restart=Never): Ensure it creates a singled Pod, not a Deployment
    (-it): This is short for --interactive, it connects your terminal directly to the pod's input/output, this is what allows you to see the output live 
    (--rm): This means remove pod, as soon as teh command finished and you disconnect, Kubernetes will automatically delete the pod
    (--): this double-dash seperates the kubectl flags from the command you want to run inside the pod
    (env): The actual command the pod will run
    # In Short: This command runs the evn command in a temporaru pod and streams the output directly to your terminal. The pod is deleted immediately after
    
    Method II: Create Pod, Then Check Logs
    kubectl run busybox --image=busybox --restart=Never --command -- env
    - Without -it, the command runs in the background, meaning the pod starts, runs env and the pod's status is changed to Completed
    - Without --rm, the pod is not deleted, it remains in the Completed state
    kubectl logs busybox
    - Since the pod still exists, you can use this command to fetch its logs
    - The "logs" for this pod will simply be the standard output from the env command it ran
    #In short: This method creates a pod, let it finish its job, and then you use a seperate command to retrieve the output (the logs) from the completed pod

* Create a busybox pod (using YAML) that runs the command "env". Run it and see the output

    The aim is to create a busybox pod by first defining it in a YAML file, then creating it, and finally checking its ouput

    kubectl run busybox --image=busybox --restart=Never --dry-run=client -o yaml --command -- env > envpod.yaml
    - Most of the stuff here is already known by now so you would have problems inderstanding this command
    #In short: This command generates the yaml file that will be used in order to create a pod

    kubectl apply -f envpod.yaml
    - This command tells Kubernetes to read the yaml file and then Kubernetes creates the pod. Once it is started it runs the env command and pod's status is set to Completed

    kubectl logs busybox
    - This command fetches the logs from the busybox pod, the log are the output of the env command

* Get the YAML for a new namespace called 'myns' without creating it

    The objective is to see the YAML "blueprint" for a namespace named myns, not to create the namespace in the cluster 

    kubectl create namespace myns -o yaml --dry-run=client
    (kubectl create namespace myns): This is the base command that would normally create us a namespace called myns
    (--dry-run=client): it instructs kubectl to only perform the operation on the client-side (your local machine) and not send the creation request to the Kubernetes cluster

* Create the YAML for a new ResourceQuota called 'myrq' with hard limits of 1 CPU, 1G memory and 2 pods without creating it

    A ResourceQuota is a Kubernetes object that provides constraints to limit the ttoal amount of resources (like CPU, memory or other stuff) that can be used within a specific namespace

    kubectl create quota myrq --hard=cpu=1,memory=1G,pods=2 --dry-run=client -o yaml 
    (kubectl create quota myrq): this is the base command to create a ResourceQuota object named myrq
    (--hard=cpu=1,memory=1G,pods=2): this flag sets the hard limits for the quota
    (-o yaml): Remember it means that it will output on the console what are the contests of the yaml file if we dont specify to which file 

* Get pods on all namespaces

    This command list all the pods running in every namespace of your Kubernetes cluster
    kubectl get po -all-namespace

    kubectl get pods
    By default only shows pods in your current namespace 

* Create a pod with image nginx called nginx and expose traffic on port 80

    kubectl run nginx --image=nginx --restart=Never --port=80
    (--port=80): This flag adds information to the pod's definition, specifiying that the container inside is listening on port 80

    This commands only creates the pod and sets the containerPort to 80, to truly expose it to traffic, you would need to create a Service 
* Change pod's image to nginx:1.24.0. Observe that the container will be restarted as soon as the image gets pulled

    The objective is to change the Nginx image of a running pod (for example nginx) from its current version to a new specific one (for example nginx:1.24.0)
    A key part of this is to observe that Kubernetes handles this change by restarting the container

    kubectl set image pod/nginx nginx=nginx:1.24.0
    (kubectl set image): This is the action it is used to update the image of a Kubernetes resource 
    (pod/nginx): This is the target, it tells kubectl to find the pod named nginx
    (nginx=nginx:1.2.4) this specifies the change 
    # In short: Kubernetes find the pod named nginx looks inside it for a container also named nginx and change its imgae to nginx:1.24.0

    There are thrw ways to verify that the change happened and that the container restarted
    - kubectl get po nginx -w
    (-w) streams the pod's status to your terminal in real-tiem
    Here you would see the pod's STATUS change from Running to Terminatin, then ContainerCreating and finally back to Running
    The RESTARTS count would also increase 

    - kubectl describe po nginx
    This command shows detailed information and most importantly an Events log at the bottom

    The third way is very confusing 

* Get pod's YAML

    kubectl get po nginx -o yaml 

* Get information about the pod, including details about potential issues (e.g. pod hasn't started)

    kubectl describe po nginx 

* Get pod logs 

    kubectl logs nginx 

* If pod crashed and restarted, get logs about the previous instance

    kubectl logs nginx -p

* Execute a simple shell on the nginx pod 

    kubectl exec -it nginx -- /bin/sh 
    (kubectl exec): This is the action, it tell Kubernetes you want to execute a command in a conteiner
    (--): It tells kubectl that all arguments after this point are the command to be executed, not kubectl flags
    (/bin/sh): This is the command we want to run inside the pod, this directory is the path to a basic shell
    Running this command effectively starts a new shell session insde the nginx container, giving a command prompt 

* Create a busybox pod that echoes 'hello world' and then exits

    The object is to create a temporary pod that runs a single command (echo 'hello world') and then stops

    kubectl run busybox --image=busybox -it --restart=Never -- echo 'hello world'
    
* Do the same, but have the pod deleted automatically when it's completed

    The objective is to run the same echo 'hello world' command from the previous example, but this time, ensure the pod is automatically deleted as soon as the command finishes.

    kubectl run busybox --image=busybox -it --rm --restart=Never -- /bin/sh -c 'echo hello world'
    (--rm): this flag instructs kubectl to automatically delete this pod as soon as it exits (in our case as soon as the echo command completes)

    To verify we can use the command kubectl get po to see all the pods in the current namespace
    Running this command will show you that busybox pod will be missing from the list because it was automatically deleted because of --rm flag 

* Create a Pod with two containers, both with image busybox and command "echo hello; sleep 3600". Connect to the second container and run 'ls'

    This is more advanced Kubernetes task which consists of creating a single pod that runs multiple containers and then interacting with a specific container inside that pod 

    A pod can hold more than one container, this is often used when a helper container (like a logger or proxy) needs to run alongside the main application container
    Since kubectl run cannot directly create a pod with two containers, this guide shows the standard workaround:
    - generate a YAML file for one container, manually edit it to add the second and then create the pod from that file

    kubectl run busybox --image=busybox --restart=Never -o yaml --dry-run=client -- /bin/sh -c 'echo hello;sleep 3600' > pod.yaml
    # This command does not create a pod, it acts as a 'YAML generator'

    After this you would have to visit with vi pod.yaml and insde the file, find the containers: section
    To add the second container, you simply copy and paste the entire block for the first container and change its name.

    Before:
    spec:
        containers:
        - args:
        - /bin/sh
        - -c
        - echo hello;sleep 3600
        image: busybox
        name: busybox  # <-- First container

    After: 
    spec:
        containers:
        - args:
        - /bin/sh
        - -c
        - echo hello;sleep 3600
        image: busybox
        name: busybox  # <-- First container
        - args:
        - /bin/sh
        - -c
        - echo hello;sleep 3600
        image: busybox
        name: busybox2 # <-- Second container (pasted and renamed)

    kubectl create -f pod.yaml
    # This command reads you new pod.yaml file and creates the pod (name busybox) with both containers (busybox and busybox2)

    kubectl exec -it busybox -c busybox2 -- /bin/sh 
    # This is how you are connecting to a specific container
    (kubectl exec -it busybix): Connects to the pod named busybox
    (-c busybox2): this is short for --container=busybox2 and tells kubectl to connect to the container with name busybox2
    (-- /bin/sh): Runs a shell inside the specific computer
    #Once you have ran this command you can execute ls inside the container's console and see the output

    kubectl exec -it busybox -c busybox2 -- ls 
    #This is the equivalent command as above just shorter 

* Create a pod with an nginx container exposed on port 80, then create init container busybox, create a volume that both the containers have acces to it

    # Okay, this is more complex problem here is everything you have to do
    - Create a pod with an nginx container exposed on port 80
    - Add a busybox init container which downloads a page using 'echo "Test" > /work-dir/index.html'
    - Make a volume of type emptyDir and mount it in both containers
    - For the nginx container, mount it on "/usr/share/nginx/html" and for the initcontainer, mount it on "/work-dir"
    - When done, get the IP of the created pod and create a busybox pod and run "wget -O- IP"

   # An Init Container is a special container in a Kubernetes pod that runs to completion before the main application containers starts

   kubectl run box --image=nginx --restart=Never --port=80 --dry-run=client -o yaml > pod-init.yaml
   # This command will generate our yaml file and in this yaml file we are going to configurate it additionally
   # This what the final yaml will have to look like check pod-init.yaml (keep in mind we need to add those initContainers and volumes parts)
    
   kubectl apply -f pod-init.yaml
   # This creates the box pod in the cluster and Kubernetes automatically runs the initContainer to completion before the main nginx

   kubectl get po -o wide
   # This commands gets the internal cluster's IP

   kubectl run box-test --image=busybox --restart=Never -it --rm -- /bin/sh -c "wget -O- $(kubectl get pod box -o jsonpath='{.status.podIP}')"
   # This is the verification, it launches a new, temporary pod (box-test) and from inside that pod, it uses wget to request the webpade from the box pod's IP 

* Create 3 pods with names nginx1,nginx2,nginx3. All of them should have the label app=v1

    # Labels are essential for organizing resources and allowing them to be selected later 

    kubectl run nginx1 --image=nginx --restart=Never --labels=app=v1
    kubectl run nginx2 --image=nginx --restart=Never --labels=app=v1
    kubectl run nginx3 --image=nginx --restart=Never --labels=app=v1
    (--labels=app=v1): This applies a metadata "tag" or lable to the pod, in this case the label's key is app and its value is v1

* Show all labels of the pods

    kubectl get po --show-labels
    (get): The action to retrive information about a resources
    (po): This is a alias for resource type pods
    (--show-labels): By default kubectl get po lists pods but does not show their labels, adding this flag adds an extra column in the output called Labels which lists 'key=value' pairs 

* Change the labels of pod 'nginx2' to be app=v2

    Method I: Using kubectl label command
    kubectl label po nginx2 app=v2 --overwrite
    (kubectl label): this command is specifically used to add, update or remove labels from resources
    (po nginx2): This specifies the resource type (po for pod) and the resource name nginx2
    (app=v2): this is the new label we want to apply 
    (--overwrite): Kubernetes does not allows two labels with the same key, thus this flags tells Kubernetes it is okay to overwrite the existing value of the app label with new one 

    Method II: The manual kubectl edit command 
    kubectl edit po nginx2
    # This command opens the YAML configuration of the nginx2 pod 
    # The user would then manually have to find the metadata:section and withing that the labels: section
    # the labels: section should be changed from app:v1 to app:v2
    # After saving and closing the file, kubectl automatically aplpies the changes to the pod in the cluster 

* Get the label 'app' for the pods (show a column with APP labels) 

    kubectl get po -L app
    (kubectl get po): This is the standard command to get all pods 
    (-L app): this is a short flag for --label-colums, it tells kuberctl to add a new column to the output adn the colum name will be APP and the values will be corresponding for each pod 

    kubectl get po --label-colums=app
    # The same command as above just more longer 

* Get only the 'app=v2' pods

    # The objective is to filter the entier list of pods and see only the ones that match the specific label app=v2

    Method I: The short flag 
    kubectl get po -l app=v2
    (kubectl get po): this gets all pods
    (-l app=v2): this is the label selectro flag, -l means --selector and app=v2 is the query, Kubernetes will return the resource where the label key app=v2

    Method II: The long flag (equality-based)
    kubectl get po --selectr=app=v2
    (--selectro=app=v2): this is equal to (-l app=v2) it is just the longer form 

* Get 'app=v2' and not 'tier=frontend' pods 

    # The objective here is to find pod with label app=2 and must not have the label tier=frontend

    kubectl get po -l app=v2,tier!=frontend # shorter form
    kubectl get po --selectro=app=v2,tier!=frontend #longer form
    (kubectl get po): get all pods
    (-l or --selector): this is the flag for applying a label selector, -l is just short for --selector 
    (app=v2,tier!=frontend): this is the query, the first condition wants labels with app=v2, the second doesnt want labels with tier=frontend

* Add a new label tier=web to all pods having 'app=v2' or 'app=v1' labels

    # The objective is to add a new label (tier=web) to specific group of pods
    
    kubectl label po-l "app in(v1,v2)" tier=web
    (kubectl label): this is the commmand used to add, update or remove labels from resources
    (po): this specifies the resource type, which is pods
    (-l "app in (v1,v2)): thi is the label selector which filters which pods the command should apply to, this tells kubectrl to find all pdos where the value of the app labels is in the set (v1,v2)
    (tier=web): this is the new label that will be added to all the pods that were matched by the selector 

* Create a deployment with image nginx:1.18.0, called nginx, having 2 replicas, defining port 80 as the port that this container exposes (don't create a service for this deployment)

    # In Kubernetes, a Deployment is a resource object that provides "declarative" instructions for managing a set of identical pods
    # Deployment is like a manager of an application, you just give it a "declarative" YAML file describing the desired state wanted
    # Basically a Deployment main job is to manage the complete lifecycle of an application's pods, it does this by controlling another object called a ReplicaSet 
    # A ReplicaSet is a Kubernetes object whose only job is to ensure that a specified number of identical pods are running at all times
    # If a pod crashes or is deleted, the ReplicaSet's controller immediately creates a new one to replace it, guaranteeing high availability and the desired pod count

    Method I: The YAML file method 

    kubectl create deployment nginx --image=nginx:1.18.0 --dry-run=client -o yaml > deploy.yaml 
    # This command will create a deploy.yaml file in the directory you have ran the command
    (--dry-run=client -o yaml): This tells kubectl to generate the YAML for the command without sending it to the cluster 

    After that open the yaml file and change a few stuff:
    - change 'replicas: 1' to 'replicas: 2'
    - add a 'ports:' section with 'containerPort: 80'

    # This command applies your changes
    kubectl apply -f deploy.yaml
    (kubectl apply -f deploy.yaml): this takes the final YAML file and creates the resources in the cluster 


    Method II: The direct command Method
    kubectl create deployment --image=nginx:1.18.0 --replicas=2 --port=80
    (kubectl create deployment nginx): creates a deployment named nginx
    (--image=nginx:1.18.0): this sets the image
    (--replicas=2): directly sets the replica count to 2
    (--port=80): directly exposes port 80 on the container 

* View the YAML of this deployment

    kubectl get deploy nginx -o yaml 
    (get deploy nginx): This is the command to retrieve or get the deployment resource named nginx, deploy is short for deployment 
    (-o yaml): This is the output formatting flag, this tells kubectrl to print the entire configuration of the fetched resource in YAML format 

* Get the YAML for one of the pods

    # This is a common two-step process because pods that are part of a Deployment have unique, randomly generated names (like nginx-7bf7478b77-gjzp8)
    # First we have to find the pod's full name and then get its YAML configuration 
    
    kubectl get po
    # This lists all the pods in the namespace and look for a pod name that starts with nginx

    kubectl get po nginx-7bf7478b77-gjzp8 -o yaml
    (kubectl get po nginx-7bf7478b77-gjzp8) this is the command to get the specific pod resource or you replace nginx-7bf7478b77-gjzp8 with whatever returned
    (-o yaml): thi is the output formatting flag, it tells kubectrl to print the pod's complete configuration and current state in YAML format 

* Check how the deployment rollout is going

    # A deployment rollout is the automated, controlled process Kubernetes uses to update your application to a new version
    # Instaed of stoppping everything at once, it gradually replaces old pods with new ones, ensuring the application stays available to users with zero downtime 

    kubectl rollout status deploy nginx
    (rollout status): This is the specific action used to check the real-time status of a deployment status

* Update the nginx image to nginx:1.19.8

    # The objective is to update the image of already existing deployment. This action will trigger a deployment rollout

    Method I: The kubectl set image command
    kubectl set image deploy nginx nginx=nginx:1.19.8
    (kubectl set image): This command is specifically designed to update container images
    (deploy nginx): This specifies the resource type and the name of th resource to update
    (nginx=nginx:1.19.8): nginx= specifies the name of the container inside the pod to update, nginx:1.19.8 specifies the new image to use 

    Method II: The kubectl edit command 
    kubectl edit deploy nginx 
    # This command will open the live YAML configuration of the nginx deployment 
    # find the image: field and change its value to nginx:1.19.8

* Check the rollout history and confirm that the replicas are OK

    # The goal is to check the update history of a deployment named 'nginx' and veryfi that its current state is correct 

    kubectl rollout history deploy nginx 
    # This command shows the history of all the updates (rollout) that have been applied to the deployment named nginx 

    kubectl get deploy nginx 
    # This command retrieves the current status of the nginx deployment

    kubectl get rs 
    # This command lists all the ReplicaSets (rs is short for replica sets) in your cluster 

* Undo the latest rollout and verify that new pods have the old image (nginx:1.18.0)

    kubectl rollout undo deploy nginx
    (rollout undo): This command is used to revert to a previouys version of a resource
    (deploy nginx): This specifies the resource you want to roll back 
    # This command takes the deployment named nginx and revert it to the version it had before the most recent update 
    # Remember that Kubernetes keeps a history of changes for each Deployment, this command triggers a new rollout, but instaed of usinga new image, it uses the confiugration from the prevoius reviosn

    kubectl get po
    # This is a command to list all the Pods in the current namespace 
    # The goal is to find the name of the new Pods that was just created by the rollback, these new pods will have a STATUS of RUNNING, select one name from the list

    kubectl describe po <selectedName> | grep i- image
    (kubectl describe po <selectedName>): retriteves detailed, human-readable information about a specific pod, for example the selectedName could be (nginx-5ff4457d65-nslc1)
    (| gep -i image): is a pipeline and gets the output (from the left side of |) and takes it as an input, it tells grep (command to search in a text) to search for the word 'image'

================================= Jobs 

    # In Kubernetes, a Job is a resource that creates one or more Pods to run a specific task to completion
    # Unlike other resources that run continuously (like a web server), a Job is meant for "one-off" tasks, ensuring that the task finishes successfully just once
    # A Job is for any task that needs to run until it is successfully finished, rather than running continuously 

* Create a job named pi with image perl:5.34 that runs the command with arguments "perl -Mbignum=bpi -wle 'print bpi(2000)'"

    kubectl create job pi --image=perl:5.34 -- perl -Mbignum=bpi -wle 'pring bpi(2000)'
    (kubectl create job pi): tells Kubernetes to create a new resource job that will run its task until it successfully completes
    (--image=perl:5.35): it will use the offical Perl iamge on version 5.34
    (--): it tells kubectl that all arguments after it are the command and arguments to be run inside the container
    (perl -Mbignum=bpi -wle 'print bpi(200)'): This is the command that runs iside the perl:5.34 container it does something but it is not in our bisness to know 
    
* Wait till it's done, get the output

    Method I: The Better Way 
    kubectl get jobs -w
    # This command watches (-w) the status of all jobs, you should find on the screen the pi job 
    kubectl logs job/pi
    # This is the command that tells Kubectl to get the logs of the pod that managed the job named pi
    kubectl delete job pi
    # This is the command that deletes the job

    Method II: The best and automated way
    kubectl wait --for=condition=complete --timeout=300s job pi
    # This command tells kubectl to wait until job pi reports its condition as complete, it will stop waiting when the job is done
    kubectl logs job/pi
    # The same command in Method I
    kubectl gelete job pi 

* Create a job with the image busybox that executes the command 'echo hello;sleep 30;echo world'

    kubectl create job busybox --image=busybox -- /bin/sh -c 'echo hello;sleep 30;echo world'
    (kubectl create job busybox): creates a new job resource named busybox
    (--image=busybox): this specifies that the job should use the busybox image
    (--) sperates the kubectl command options from the command that will be run inside the container

* Follow the logs for the pod (you'll wait for 30 seconds)

    kubectl get po
    # This command lists all the pods in the current namespace, you will have to search for the name of the pod it is in the first collumn

    kubectl logs <nameOfThePod> -f 
    # This command fetches the logs from the pod named <nameOfThePod>, -f means follow and it shows live what did the pod do 

* See the status of the job, describe it and see the logs

    kubectl get jobs
    # This command lists a summary of all Job resources in the current Kubernetes namespace
    # It will show the name of the jobs, how many pods are desired and how many have actually completed and how long the job took to run 

    kubectl describe jobs busybox
    # This command gives a detailed, human-readable description of the specific job names busybox, it is used for debugging and inspection

    kubectl logs job/busyvox
    # This command fetches the logs from the pod that was run by the job named busybox

* Delete the job

    kubectl delete job busybox 

* Create the same job, make it run 5 times, one after the other. Verify its status and delete it

    kubectl create job --image=busybox --dry-run=client -o yaml -- /bin/sh -c 'echo hello;sleep 30;echo world' > job.yaml 
    (kubectl create jo busybox): Creates a job with the name of busybox
    (--dry-run=client): this tells kubectl dont create this resource in the cluster
    (-o yaml): this tells kubectl instead of creating it to print the YAML file to a file
    (> job.yaml) this is a standart shell command that takes the output and saves it into a new file named job.yaml

    Check job.yaml and add line completions: 5 to the spec section of the yaml file 
    # By default a job has completions: 1

    kubectl create -f job.yaml
    # This command tells Kubernetes to create whatever resource is defined in the job.yaml

    kubectl get job busybox -w
    # This command watched the status of the busybox job 

    kubectl delete job busybox 
    # This command deletes the job 

* Create the same job, but make it run 5 parallel times

    Use again job.yaml since we will need to change it
    Open the yaml file and add parallelism: 5 under spec: section
    # This tells Kubernetes that you are allowed to run up to 5 pods at the same time for this job 
    # By default completions might not be set, but it will gain the value of parallelism

    kubectl create -f job.yaml
    # This command creates the job in the cluster using the modified file, Kubernetes will immediately start creating all 5 pods simultaneously 

    kubectl get jobs
    # This command checks the status of the jobs 

================================= Cron Jobs

    # A kubernetes conjob is a resource that automatically creates Jobs on a repeating schedule 
    # It is used to automate recurring tasks, such as running a backup every night at 2AM, generating a report every Monday, or cleaning up old data every hour 

* Create a cron job with image busybox that runs on a schedule of "*/1 * * * *" and writes 'date; echo Hello from the Kubernetes cluster' to standard output

    kubectl create cronjob busybox --image=busybox --shcedule="*/1 * * * *" -- /bin/sh -c "data; echo Hello from the Kubernetes cluster"
    (kubectl create cronjob busybox): creates a new CronJob resource named busybox
    (--image=busybox): Tells the CronJob to use the lightweight busybox container image for its tasks 
    (--schedule="*/1 * * * *"): This is the chron synthax it means run the job every 1 min

* See its logs and delete it

    kubectl get po
    # This command lists all the pods in the namespace

    kubectl logs <busybox-***> 
    # This command fetches the logs from the specific pod you identified in the first step

    kubectl delete cj busybox
    # This command deletes the CronJob itself and it doesnt just delete the pods that already ran, but it stops any future jobs from being created by this schedule

* Create the same cron job again, and watch the status. Once it ran, check which job ran by the created cron job. Check the log, and delete the cron job

    kubectl get cj
    # This command lists all CronJobs in the namespace, allowing to confirm that certain CronJob exists 

    kubectl get jobs --watch
    # This commmand watches the list of jobs, this would run and wait for a new job to automatically appear 

    kubectl get po --show-labels
    # This liss all pods including their labels 

    